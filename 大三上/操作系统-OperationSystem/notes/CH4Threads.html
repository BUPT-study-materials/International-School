<html>
<head>
  <title>CH4:Threads</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602326 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="852"/>
<h1>CH4:Threads</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/12/17 12:05</i></td></tr>
<tr><td><b>作者：</b></td><td><i>dmadkr1217</i></td></tr>
</table>
</div>
<br/>

<div><span><h1>CH4:Threads</h1><div style="padding-left:40px;">*thread libraries</div><div><b>Process is the minimum unit for allocating resources</b></div><div><b>Thread is the minimum unit for executing code</b></div><div><br/></div><div><b>1.Motivation</b></div><div style="padding-left:40px;">//multithreaded</div><div style="padding-left:40px;">//threads run within application</div><div style="padding-left:40px;">Multiple tasks with the application can be implemented by separate threads</div><div style="padding-left:40px;">Process creation is heavy-weight, thread creation is light </div><div style="padding-left:40px;">simplify code, increase efficiency</div><div style="padding-left:40px;">kernels are generally multithreaded</div><img src="CH4Threads_files/Image.png" type="image/png" data-filename="Image.png" width="659.5555555555555px"/><div><br/></div><div><b>2.Benifits</b></div><div style="padding-left:40px;"><b>Responsiveness </b></div><div style="padding-left:80px;">allow continued execution if part of process is blocked</div><div style="padding-left:40px;"><b>Resource sharing</b></div><div style="padding-left:80px;">threads share resources of process, easier than shared memory or message pasing</div><div style="padding-left:40px;"><b>Economy</b></div><div style="padding-left:80px;">cheaper than process creation, lower overhead than context switching</div><div style="padding-left:40px;"><b>Scalability</b></div><div style="padding-left:80px;">take advantage of multiprocessor architectures</div><div><b>3.Multicore Programming</b></div><div style="padding-left:40px;"><b>multicore or multiprocessor systems</b> challenges:</div><div style="padding-left:80px;">dividing activities</div><div style="padding-left:80px;">balance data splitting</div><div style="padding-left:80px;">data dependency</div><div style="padding-left:80px;">testing and debugging</div><div style="padding-left:40px;"><b>Parallelism</b> implies a system can perform more than one task simutaneously</div><div style="padding-left:40px;"><b>concurrency</b> : more than one task,allowig all tasks making progress</div><div style="padding-left:120px;">single processor/core, scheduler providing concurrency</div><img src="CH4Threads_files/A6.png" type="image/png" data-filename="A6.png"/><div style="padding-left:80px;">并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在</div><div style="padding-left:80px;">并行要求程序能够同时执行多个操作</div><div style="padding-left:80px;">而并发只是要求程序假装同时执行多个操作</div><div style="padding-left:40px;">-Types of parallelism</div><div style="padding-left:80px;">1.Data parallelism    -distributes subsets of the same data across multiple cores, same operation on  each</div><div style="padding-left:80px;">2.Task parallelism    -distributing threads across cores, each thread performing unique operation</div><div>                                                </div><div style="padding-left:40px;">-CPU have <b>cores</b> as well as <b>Hardware thread</b>s</div><img src="CH4Threads_files/A7.png" type="image/png" data-filename="A7.png" width="479.8487544483986px"/><img src="CH4Threads_files/Image [1].png" type="image/png" data-filename="Image.png" width="513.7777777777777px"/><div style="padding-left:40px;"><b>-Amdahl's Law</b></div><div style="padding-left:80px;">performance gains from adding additional cores to an application</div><div style="padding-left:80px;">S:serial portion(if application is 75% parallel,25%serial, serial portion = 0.25)</div><div style="padding-left:80px;">N:processing cores</div><img src="CH4Threads_files/A7 [1].png" type="image/png" data-filename="A7.png"/><div style="padding-left:80px;">as N -&gt; infinity, speedup approaches 1/S</div><div style="padding-left:80px;">serial portion of an application has dispproportionate effect on perfprmance gained by adding cores</div><div style="padding-left:40px;"><b>-User threads and Kernel Threads</b></div><div style="padding-left:80px;"><b>User threads</b>    -management done by user-level threads library</div><div style="padding-left:120px;">3 primary thread libraries:</div><div style="padding-left:160px;">POSIX Pthreads</div><div style="padding-left:160px;">Windows threads</div><div style="padding-left:160px;">Java threads</div><div style="padding-left:80px;"><b>Kernel threads</b> -Supported by Kernel</div><div style="padding-left:120px;">Linux,Solaries,Windows,Tru64 UNIX,Mac OS X</div><div style="padding-left:40px;"><b>-Multithreading models</b></div><div style="padding-left:80px;">1.Many-to-One</div><div style="padding-left:120px;">Many <b>user-level threads</b> mapped to<b> single Kernel thread</b></div><div style="padding-left:120px;">one thread blocking causes all to block</div><div style="padding-left:120px;">Multiple threads may not run in parallel on multicore system because <b>only one thread may be in kernel at a time</b></div><div style="padding-left:120px;">Not used</div><div style="padding-left:80px;">2.One-toOne</div><div style="padding-left:120px;">Each user-level thread maps to kernel thread</div><div style="padding-left:120px;">Creating a user-level thread creates a kernel thread</div><div style="padding-left:120px;">More  concurrency than many-to-one</div><div style="padding-left:120px;">Number of thread due to overhead</div><div style="padding-left:160px;">Linux, windows Sloaris9</div><div style="padding-left:80px;">3.Many to many</div><div style="padding-left:120px;">allow many user threads to be mapped to manny kernel threads</div><div style="padding-left:120px;">allow OS to create a sufficient number of kernel threads</div><div style="padding-left:80px;">4.Two-level model</div><div style="padding-left:120px;">similar to M:M, allow a user thread to be bound to a kernel thread</div><div style="padding-left:40px;">-<span style="background-color: #ffdebd;"><b>Thread Libraries *</b></span></div><div style="padding-left:80px;"><b>thread library </b>provides programmer with API for creating and managing threads</div><div style="padding-left:80px;">2 promary ways:</div><div style="padding-left:120px;">1.Library entirely in<b> user</b> space, </div><div style="padding-left:160px;">no kernel support, all codes and data structures exist in user space. invoking a function in the library results in a call in user space, and not a system call</div><div style="padding-left:120px;"><b>2.Kernel-level</b> library supported by the OS</div><div style="padding-left:160px;">code and data structures exists in the kernel space, invoking a function results in a system call to the kernel.</div><div style="padding-left:80px;">two general strategies for <b>creating multiple threads: </b></div><div style="padding-left:160px;"><b>1.asynchronous threading,</b></div><div style="padding-left:200px;"><b> </b>once the parent creates a child thread, the parent resumes its execution, so that the parent and child execute concurrently. Each thread runs independently </div><div style="padding-left:160px;"><b>2.Synchronous threading</b> </div><div style="padding-left:160px;">         parent thread creates one or more children and then must wait for all of its children to terminate                 before it resumes</div><div style="padding-left:200px;"><b><i>fork-join </i></b>strategy. the threads created by the parent perform work concurrently, but the parent cannot continue until this work has been completed. </div><div style="padding-left:40px;"><span style="background-color: #ffdebd;"><b>-Pthreads *</b></span></div><div style="padding-left:80px;">Either user-level or kernel-level</div><div style="padding-left:80px;">Specification, not implementation</div><div style="padding-left:120px;">API specifies behavior of the thread library,</div><div style="padding-left:80px;"><b>Pthread Example</b></div><div style="padding-left:160px;">/*get the default attributes*/</div><div style="padding-left:160px;">pthread_attr_init(&amp;attr)</div><div style="padding-left:160px;">/*create the thread*/</div><div style="padding-left:160px;">pthread_create(&amp;tid,&amp;attr,runner,argv[1]);</div><div style="padding-left:160px;">/*wait for the thread to exit*/</div><div style="padding-left:160px;"><b>pthread_join</b>(tid,NULL);</div><div><br/></div><div style="padding-left:160px;">void *runner(void *param)</div><div style="padding-left:160px;">{</div><div style="padding-left:200px;">int i,upper = atoi(param);</div><div style="padding-left:200px;">sum = 0;</div><div style="padding-left:200px;">for(i = 1;i&lt;=upper;i++)</div><div style="padding-left:240px;">sum+=1;</div><div style="padding-left:200px;">pthread_exit(0);</div><div style="padding-left:160px;">}</div><div style="padding-left:120px;"><b>threads code for joining 10 threads:</b></div><div style="padding-left:160px;">#define NUM_THREADS 10</div><div style="padding-left:160px;">pthreads_t wokers[NUM_THREADS];</div><div style="padding-left:160px;">for(int i = 0; i&lt; NUM_THREADS; i++)</div><div style="padding-left:200px;"><b>pthread_join</b>(workers[i], NULL);</div><div style="padding-left:40px;"><br/></div><div style="padding-left:120px;"><b>Windows Multithreaded C Program</b></div><div style="padding-left:160px;">/*create the thread*/</div><div style="padding-left:160px;">ThreadHandle = CreateThread(</div><div style="padding-left:200px;">NULL,/*default security attributes */</div><div style="padding-left:200px;">0,    /*default stack size*/</div><div style="padding-left:200px;">Summation,    /*thread function*/</div><div style="padding-left:200px;">&amp;Param, /*parameter to thread function*/</div><div style="padding-left:200px;">0,    /*default creation flags*/</div><div style="padding-left:200px;">&amp;ThreadId);    /*returns the thread identifier */</div><div style="padding-left:80px;"><br/></div><div style="padding-left:160px;">If(ThreadHandle != NULL) {</div><div style="padding-left:200px;">/*wait for the thread to finish * /</div><div style="padding-left:200px;"><b>WaitForSingleObject</b>(ThreadHandle,INFINITE);</div><div style="padding-left:80px;"><br/></div><div style="padding-left:200px;">/*close the thread handle*/</div><div style="padding-left:200px;">CloseHandle(ThreadHandle);</div><div style="padding-left:80px;"><br/></div><div style="padding-left:200px;">printf(&quot;sum = %d\n&quot;,sum);</div><div style="padding-left:160px;">}</div><div style="padding-left:120px;">}</div><div style="padding-left:80px;"><span style="background-color: #ffdebd;"><b>-Java Threads</b></span></div><div style="padding-left:120px;">managed by JVM</div><div style="padding-left:120px;">created by two ways:</div><div style="padding-left:160px;">1/Extending Thread class, override run() method</div><div style="padding-left:160px;">2.implementing the Runnable interface</div><div style="padding-left:200px;">publi interface Runnable</div><div style="padding-left:200px;">{</div><div style="padding-left:240px;">public abstract void run();</div><div style="padding-left:200px;">}</div><div style="padding-left:120px;"><b>start() method:</b></div><div style="padding-left:160px;">1.allocated memory and initializes a new thread in JVM</div><div style="padding-left:160px;">2.calls the run() method, making the thread eligble to be run by the JVM.(start() calls run(), dont call run() directly)</div><div style="padding-left:120px;"><b>Sharing data</b> :</div><div style="padding-left:240px;">in Windows and Pthreads: global data</div><div style="padding-left:240px;">in Java:passing references to the shared object and approproate thread</div><div style="padding-left:120px;"><b>Java Multithreaded Program example:</b></div><div style="padding-left:160px;">class Summation implements Runnable</div><div style="padding-left:160px;">{</div><div style="padding-left:200px;">private int upper;</div><div style="padding-left:200px;">private Sum sumValue;</div><div><br/></div><div style="padding-left:200px;">public Summation(int upper, Sum sumValue){</div><div style="padding-left:200px;">     this.upper = upper;</div><div style="padding-left:240px;">this,sumValue = sumValue;</div><div style="padding-left:200px;">}</div><div style="padding-left:200px;">public void run()    {</div><div style="padding-left:240px;">int sum = 0;</div><div style="padding-left:240px;">for(int i = 0; i&lt;=upper; i++）</div><div style="padding-left:280px;">sum += i;</div><div style="padding-left:240px;">sumValue.setSum(sum);</div><div style="padding-left:200px;">}</div><div style="padding-left:160px;">}</div><div style="padding-left:160px;">public class Driver</div><div style="padding-left:160px;">{</div><div style="padding-left:200px;">public static void main(String[] args){</div><div style="padding-left:240px;">if(args.length &gt; 0){</div><div style="padding-left:280px;">//error</div><div style="padding-left:240px;">}else{</div><div style="padding-left:280px;">Thread thrd = new Thread(new Summation(upper, sumObject));</div><div style="padding-left:280px;">thrd.start();</div><div style="padding-left:280px;">try{</div><div style="padding-left:320px;">thrd.join();</div><div style="padding-left:280px;">}catch(InterruptedException ie){}</div><div style="padding-left:240px;">}</div><div style="padding-left:200px;">}</div><div style="padding-left:160px;">}</div><div style="padding-left:80px;"><b>-Implicit Threading</b></div><div style="padding-left:120px;">Creation and management of threads deone by compilers and run-time libraries rather than programmers</div><div style="padding-left:120px;">three method explored:</div><div style="padding-left:160px;">Thread pools</div><div style="padding-left:160px;">OpenMP</div><div style="padding-left:160px;">Grand Crentral Dispatch</div><div style="padding-left:120px;">1.Thread Pools</div><div style="padding-left:160px;">create a number of threads in a pool where they await work</div><div style="padding-left:160px;">Advantages:</div><div style="padding-left:200px;">faster to service a request with a existing thread</div><div style="padding-left:200px;">allows number of threads of an application to be bounded by the pool</div><div style="padding-left:200px;">allows different strategies for running task</div><div style="padding-left:120px;">2.OpenMP</div><div style="padding-left:160px;">identifies <b>parallel regions </b></div><div style="padding-left:120px;">3.Grand Crentral Dispatch</div><div style="padding-left:80px;"><b>-Semantis of fork() and exec()</b></div><div style="padding-left:120px;">fork() duplicate the calling thread/ all threads</div><div style="padding-left:120px;">exec() usually works as normal </div><div style="padding-left:160px;">-replace the running process including all threads </div><div style="padding-left:160px;">在fork后的子进程中使用exec函数族，可以装入和运行其它程序（子进程替换原有进程，和父进程做不同的事）</div><div style="padding-left:80px;"><b>--Signal Handling</b></div><div style="padding-left:120px;"><b>Signals</b> are used in UNIX systems to notify a process that a particular event has occured.</div><div style="padding-left:120px;">A <b>signal handle</b>r is used</div><div style="padding-left:160px;">1.Signal is generated by particular evenr</div><div style="padding-left:160px;">2.signal is delivered to a process</div><div style="padding-left:160px;">3.Signal is handled by one of two signal handlers:</div><div style="padding-left:200px;">default/user-defined</div><div style="padding-left:120px;">Every signal has<b> default handler </b>kernel runs</div><div style="padding-left:160px;">1.user-defined signal can override default</div><div style="padding-left:160px;">2.for <b>single-threaded</b>,signal delivered to process</div><div style="padding-left:120px;">Where should a signal be delivered for multi-threaded? </div><p style="padding-left:160px;">Deliver the signal to the thread to which the signal applies</p><p style="padding-left:160px;">Deliver the signal to every thread in the process</p><p style="padding-left:160px;">Deliver the signal to certain threads in the process</p><div style="padding-left:160px;">Assign a specific thread to receive all signals for the process</div><div style="padding-left:80px;"><b>-Thread Cancellation</b></div><div style="padding-left:120px;">Terminating a thread before it has finished</div><div style="padding-left:120px;">thread to be canceled is <b>target thread</b></div><div style="padding-left:120px;"><b>Two general approaches:</b></div><div style="padding-left:160px;"><b>1.Asychronous cancellation </b>terminates the target thread <b>immediately</b></div><div style="padding-left:160px;"><b>2.Deferred cancellation</b> allows the target thread to<b> periodically</b> check if it should be cancelled</div><div style="padding-left:80px;"><b>-Thread-Local Storage( TLS )</b></div><div style="padding-left:120px;"><b>TLS </b>allows each thread to have its own copy of data</div><div style="padding-left:120px;">different from local variables:</div><div style="padding-left:160px;">LV only visible during single function invocation</div><div style="padding-left:160px;">TLS is visible across function invocations</div><div style="padding-left:120px;">similar to static.</div><div style="padding-left:160px;">TLS is unique to each thread</div><div style="padding-left:80px;"><b>-Scheduler Activations</b></div><div style="padding-left:120px;">we use an intermedite data structure between user and Kernel threads -<b> lightweight process( LWP)</b></div><div style="padding-left:160px;">每个LWP连接一个kernel thread， 连接user thread</div><div style="padding-left:80px;"><br/></div></span>
</div></body></html> 