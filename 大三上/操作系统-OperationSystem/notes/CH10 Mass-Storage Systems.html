<html>
<head>
  <title>CH10 Mass-Storage Systems</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602326 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="954"/>
<h1>CH10 Mass-Storage Systems</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/12/18 23:40</i></td></tr>
<tr><td><b>作者：</b></td><td><i>dmadkr1217</i></td></tr>
</table>
</div>
<br/>

<div><span><h1>CH10 Mass-Storage Systems</h1><div style="padding-left:40px;"><b>1.Overview of Mass Storage  Structure</b></div><div style="padding-left:80px;"><b>Magnetic disks </b>provide bulk of secondary storage of modern computers</div><div style="padding-left:120px;">-Drives rotate at 60 to 250 times per second</div><div style="padding-left:120px;"><b>-Transfer rate </b>is rate at which data flow  between drive and computer</div><div style="padding-left:120px;">-<b>Positioning time </b>(<b>random-access time</b>) is  time to move disk arm to desired cylinder (<b>seek time</b>) and time for  desired sector to rotate under the disk head (<b>rotational latency</b>)</div><div style="padding-left:120px;">-<b>Head crash </b>results from disk head making  contact with the disk urface -- That’s bad</div><div style="padding-left:80px;">Drive attached to computer via <b>I/O bus</b></div><div style="padding-left:120px;">Busses vary, including <b>EIDE</b>, <b>ATA</b>, <b>SATA</b>, <b>USB</b>,  <b>Fibre Channel</b>, <b>SCSI, </b>SAS, Firewire</div><div style="padding-left:120px;"><b>Host controller </b>in computer uses <b>bus</b> to talk  to <b>disk controller </b>built into drive or storage array</div><div style="padding-left:40px;"><b>2.Hard Disk Performance</b></div><div style="padding-left:80px;"><b>Access Latency </b>= <b>Average access time </b>=  average seek time + average latency</div><div style="padding-left:80px;"><b>Average I/O time</b> = average access time + (amount  to transfer / transfer rate) + controller overhead</div><div style="padding-left:40px;"><b>3.Solid-State Disks</b></div><div style="padding-left:80px;">Nonvolatile memory used like a hard drive</div><div style="padding-left:80px;">Many technology variations</div><div style="padding-left:80px;">Can be more reliable than HDDs</div><div style="padding-left:80px;">More expensive per MB</div><div style="padding-left:80px;">Maybe have shorter life span</div><div style="padding-left:80px;">Less capacity</div><div style="padding-left:80px;">much faster</div><div style="padding-left:80px;">Buses can be too slow -&gt; connect directly to  PCI for example</div><div style="padding-left:80px;">No moving parts, so no seek time or rotational  latency</div><div style="padding-left:40px;"><b>4.Magnetic Tape</b></div><div style="padding-left:80px;">Was early secondary-storage medium</div><div style="padding-left:80px;">Relatively permanent and holds large quantities  of data</div><div style="padding-left:80px;">Access time slow</div><div style="padding-left:80px;">Random access ~1000 times slower than disk</div><div style="padding-left:80px;">Mainly used for backup, storage of  infrequently-used data, transfer medium between systems</div><div style="padding-left:80px;">200GB to 1.5TB typical storage</div><div style="padding-left:40px;"><b>5.Disk Structure</b></div><div style="padding-left:80px;">Disk drives are addressed as large <b>1-dimensional  arrays</b> of <b>logical blocks</b>,</div><div style="padding-left:120px;"><b>Logical block</b> is the <b>smallest  unit of transfer</b></div><div style="padding-left:80px;">The 1-dimensional array of logical blocks is  mapped into the sectors of the disk sequentially</div><div style="padding-left:120px;">Sector 0 is the first sector of the first track  on the outermost cylinder</div><div style="padding-left:120px;">映射按顺序通过该轨道进行，然后圆柱体中的其余轨道从最外层到最内层</div><div style="padding-left:40px;"><span style="background-color: #ffdebd;"><b>6.Disk Scheduling</b></span></div><div style="padding-left:80px;">The operating system is responsible for using  hardware efficiently — for the disk drives, this means  having a fast access time and disk bandwidth</div><div style="padding-left:80px;">-<b>Minimize seek time </b>» seek distance</div><div style="padding-left:80px;">-Disk <b>bandwidth </b>    : </div><div style="padding-left:120px;">the <b>total number of bytes</b>  transferred, divided by the total time between <b>the first  request</b> for service and the completion of<b> the last transfer</b></div><div style="padding-left:80px;">There are many sources of disk I/O request</div><div style="padding-left:160px;">OS</div><div style="padding-left:160px;">System processes</div><div style="padding-left:160px;">Users processes</div><div style="padding-left:80px;">I/O request includes input or output mode, disk  address, memory address, number of sectors to transfer</div><div style="padding-left:80px;">OS maintains queue of requests, per disk or  device</div><div style="padding-left:80px;">Idle disk can immediately work on I/O request,  busy disk means work must queue,</div><div style="padding-left:120px;">Optimization algorithms only make sense<b> when a  queue exists</b></div><div style="padding-left:80px;"><b>1.FCFS</b></div><div style="padding-left:120px;">The wild swing from 122 to 14 and then back to 124 illustrates the problem with this schedule. I</div><img src="CH10 Mass-Storage Systems_files/E1.png" type="image/png" data-filename="E1.png" width="399.0348837209302px"/><div style="padding-left:80px;"><b>2.SSTF - Shortest Seek Time First</b></div><div style="padding-left:80px;">selects the request with th<b>e minimum seek time from the current head position</b></div><div style="padding-left:80px;">is a form of SJF(shortest-job-first) scheduling</div><div style="padding-left:80px;"><b>Problem: </b>In theory, a continual stream of requests near one another could cause the request for cylinder 186 to wait indefinitely</div><img src="CH10 Mass-Storage Systems_files/E2.png" type="image/png" data-filename="E2.png" width="390.71808510638294px"/><div style="padding-left:80px;"><b>3.SCAN Scheduling(the elevator algorithm)</b></div><div style="padding-left:80px;">-<b>starts at one end of the disk, and moves toward  the other end</b>, servicing requests until it gets to  the other end of the disk, where the head movement is reversed and  servicing continues.</div><div style="padding-left:80px;"><b>Problem:</b>如果请求是均匀密集的，那么最大的请求密度位于磁盘的另一端，并且这些请求等待的时间最长</div><img src="CH10 Mass-Storage Systems_files/E3.png" type="image/png" data-filename="E3.png" width="355.64270152505446px"/><div style="padding-left:80px;"><b>4.C-SCAN Scheduling</b>(<b>Circular SCAN)</b></div><div style="padding-left:120px;"><b>-从一端移动到另一端的时间也算在开销之中</b></div><div style="padding-left:120px;">When the head reaches the other end, however, it<b> immediately returns to the beginning</b> of the disk without servicing any requests on the return trip</div><img src="CH10 Mass-Storage Systems_files/E4.png" type="image/png" data-filename="E4.png"/><div style="padding-left:80px;"><b>5.LOOK Sheduling/C-LOOK Sheduling</b></div><div style="padding-left:120px;">the arm goes only as far as the final request in each direction. Then, it reverses direction immediately,without going all the way to the end of the disk. Versions of SCAN and C-SCAN that follow this pattern are called <b>LOOK </b>and <b>C-LOOK scheduling</b></div><img src="CH10 Mass-Storage Systems_files/E5.png" type="image/png" data-filename="E5.png" width="399.80582524271847px"/><div style="padding-left:80px;"><b>6.Algorithm Selecion</b></div><div style="padding-left:120px;">-SSTF is common and has a natural appeal</div><div style="padding-left:120px;">-SCAN and C-SCAN perform better for systems that place a <b>heavy load</b> on the disk, because they are less likely to cause a starvation problem.</div><div style="padding-left:120px;">-Performance depends on the number and types of  requests</div><div style="padding-left:120px;">-Requests for disk service can be influenced by the  file-allocation method</div><div style="padding-left:120px;">-Either <b>SSTF or LOOK </b>is a reasonable choice for the  default algorithm</div><div style="padding-left:40px;"><b>7.Disk Management</b></div><div style="padding-left:80px;">Before a disk can store data, it must be<b> divided into sectors </b>that the<b> disk controller can read and write</b>. This process is called <b>low-level formatting</b>, or <b>physical formatting</b></div><div style="padding-left:80px;"><b>-Low-level formatting</b> fills the diskwith a special data structure for each sector.</div><div style="padding-left:120px;">Each sector can hold header information, plus data,  plus error correction code (<b>ECC</b>)</div><div style="padding-left:80px;">To use a disk to hold files, the<b> operating system  still needs to record its own data structures on the disk</b></div><div style="padding-left:120px;"><b>1.Partition </b>the disk into one or more groups of  cylinders, each treated as a logical disk</div><div style="padding-left:120px;"><b>2.Logical formatting </b>or “making a file system”</div><div style="padding-left:120px;">3.To increase efficiency most file systems group blocks  into <b>clusters</b></div><div style="padding-left:160px;">Disk I/O done in blocks</div><div style="padding-left:160px;">File I/O done in clusters</div><div style="padding-left:80px;">Raw disk access for apps that want to do their  own block management, keep OS out of the way (databases  for example</div><div style="padding-left:80px;"><b>Boot block </b>initializes system</div><div style="padding-left:120px;">The bootstrap is <b>stored in ROM</b></div><div style="padding-left:120px;"><b>Bootstrap loader </b>program stored in boot blocks  of boot partition</div><div style="padding-left:80px;">Methods such as <b>sector sparing </b>used to handle  bad blocks</div><div style="padding-left:40px;"><b>8.Swap-Space Management</b></div><div style="padding-left:80px;">Swap-space — <b>Virtual memory uses disk space as an  extension of main memory</b></div><div style="padding-left:80px;">Swap-space can be carved out of the normal file system,  or, more commonly, it can be in a separate disk partition (raw)</div><div style="padding-left:80px;">Swap-space management</div><div style="padding-left:120px;">4.3BSD allocates swap space when process starts; holds  text segment (the program) and data segment</div><div style="padding-left:120px;">Kernel uses <b>swap maps </b>to track swap-space use</div><div style="padding-left:120px;">Solaris 2 allocates swap space only when a dirty page is  forced out of physical memory, not when the virtual memory page is first created</div><div style="padding-left:160px;">File data written to swap space until write to file  system requested</div><div style="padding-left:160px;">Other dirty pages go to swap space due to no other home</div><div style="padding-left:160px;">Text segment pages thrown out and reread from the file  system as needed</div><div style="padding-left:80px;"><br/></div><div style="padding-left:120px;"><br/></div></span>
</div></body></html> 