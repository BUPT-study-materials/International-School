<html>
<head>
  <title>CH7 Deadlocks</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602326 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="896"/>
<h1>CH7 Deadlocks</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/12/18 12:43</i></td></tr>
<tr><td><b>作者：</b></td><td><i>dmadkr1217</i></td></tr>
</table>
</div>
<br/>

<div><span><h1>CH7 Deadlocks</h1><div>1.<b>System Model</b></div><p style="padding-left:80px;">System consists of resources</p><div style="padding-left:80px;">Resource types <i>R</i>1, <i>R</i>2, . . ., <i>R</i>m</div><div style="padding-left:120px;"><i>CPU cycles, memory space, I/O devices</i></div><p style="padding-left:80px;">Each resource type <i>R</i>ihas <i>W</i>iinstances.</p><div style="padding-left:80px;">Each process utilizes a resource as follows:</div><p style="padding-left:120px;"><b>request </b></p><p style="padding-left:120px;"><b>use </b></p><div style="padding-left:120px;"><b>release</b></div><div><span style="background-color: #ffdebd;"><b>2.Deadlock Characterization</b></span></div><div style="padding-left:40px;"> <b>死锁产生需要同时满足四个条件：</b></div><div style="padding-left:40px;">1.<b>Mutual exclusion: </b>only one process at a time can use a resource</div><div style="padding-left:40px;">2.<b>Hold and wait</b>: a process holding at least one resource is waiting to acquire additional resources held by other processes</div><div style="padding-left:40px;">3.<b>No preemption:</b> a resource can be released only voluntarily by the process holding it, after that process has completed its task</div><div style="padding-left:40px;">4.<b>Circular wait: </b>   there exists a set of waiting process such that P0 is waiting for resource held by P1, .....Pn is waiting for a aresource held by P0</div><div>3.<b>Resource-Allocation Graph</b></div><div style="padding-left:40px;">P-process</div><div style="padding-left:40px;">R-resource</div><div style="padding-left:40px;">request edge: P-&gt;R</div><div style="padding-left:40px;">assignment edgr :R-&gt;P</div><div style="padding-left:40px;">Bascic Facts:</div><p style="padding-left:80px;">If graph contains no cycles -&gt; no deadlock</p><div style="padding-left:80px;">If graph contains a cycle -&gt;</div><p style="padding-left:120px;">if only one instance per resource type, then deadlock</p><div style="padding-left:120px;">if several instances per resource type, possibility of deadlock</div><div>4.<b>Methods for Handling Deadlocks</b></div><div style="padding-left:40px;">1.Ensure that the system will <b><i>never</i></b>enter a deadlock state:</div><p>                Deadlock prevention</p><div>                Deadlock avoidence</div><div style="padding-left:40px;">2.Allow the system to enter a deadlock state and then recover</div><div style="padding-left:40px;">3.Ignore  It is then up to the application <b>developers</b>to write  programs that handle deadlocks.</div><div><span style="background-color: #ffdebd;">5.<b>Deadlock Prevention</b></span></div><div style="padding-left:40px;"><b>-Restrain </b>the ways that requests can be made  限制请求发出的方式</div><div style="padding-left:40px;">1.<b>Mutual Exclusion</b>    </div><div style="padding-left:80px;"><b>-not required for sharable resources</b> (e.g., read-only files); must hold for non-sharable resources. Thus, cannot prevent deadlocks by denying the  mutual-exclusion condition for nonsharable resources</div><div style="padding-left:40px;">2.<b>Hold and Wait</b>    </div><div style="padding-left:80px;">–must guarantee that whenever a process <b>requests a resource</b>,  it <b>does not hold any other resources</b></div><div style="padding-left:120px;">-Require process to request and be allocated all its resources<b> before it begins  execution,</b> //一开始就请求全部资源并一直hold，尽管某些资源已经使用完（DVD disk printer）</div><div style="padding-left:160px;"><b>or </b>allow process to request resource<b>s only when the process has none allocated </b>to it.//只要上一步请求的资源被释放就可以请求下一步需要的资源（DVD,DISK-&gt;释放DVD，disk-&gt;PRINTER-&gt;释放 printer）</div><div style="padding-left:120px;">-Disadvantages: Low resource utilization; starvation possible</div><div style="padding-left:40px;">3.<b>No Preemption</b></div><div style="padding-left:80px;"><b>-</b>If a process that is holding some resources requests another resource that  cannot be immediately allocated to it, then all resources currently being held  are released</div><div style="padding-left:80px;">-Preempted resources are added to the list of resources<b> for which the process  is waiting</b></div><div style="padding-left:80px;"><b>-</b>Process will be restarted only when it can regain its old resources, as well as  the new ones that it is requesting</div><div style="padding-left:80px;">进程等待的资源被加入抢占的资源列表</div><div style="padding-left:80px;">如果一个占有资源的进程请求的其他资源不能立刻被分配给他，所有他占有的资源都被释放</div><div style="padding-left:80px;">进程只有在重新获得他的旧的资源和他请求的新资源时才可以重启</div><div style="padding-left:80px;"><b>-教材：</b></div><div style="padding-left:120px;">if a process requests some resources, we first check whether</div><div style="padding-left:120px;">they are available. If they are, we allocate them. If they are not, we check</div><div style="padding-left:120px;">whether they are allocated to some other process that is <b>waiting</b> for additional</div><div style="padding-left:120px;">resources. If so,we preempt the desired resources from the waiting process and</div><div style="padding-left:120px;">allocate them to the requesting process. If the resources are neither available</div><div style="padding-left:120px;">nor held by a waiting process, the requesting process must wait. While it is</div><div style="padding-left:120px;">waiting, some of its resources may be preempted, but only if another process</div><div style="padding-left:120px;">requests them. A process can be restarted only when it is allocated the new</div><div style="padding-left:120px;">resources it is requesting and recovers any resources that were preempted</div><div style="padding-left:120px;">while it was waiting.</div><div style="padding-left:40px;">4.<b>Circular Wait</b></div><div style="padding-left:80px;">–impose a total ordering of all resource types, and require that each process  requests resources in an increasing order of enumeration</div><div style="padding-left:80px;">-Each process can request resources only in an increasing order of enumeration. </div><div style="padding-left:80px;">1.a process can initially request any number of instances of a resource type—say, <i>Ri</i>. After that, the process can request instances of resource type <i>Rj </i>if and only if <i>F</i>(<i>Rj </i>) &gt; <i>F</i>(<i>Ri </i>).</div><div style="padding-left:80px;">2. can require that a process requesting an instance of resource type <i>Rj </i>must have released any resources <i>Ri </i>such that <i>F</i>(<i>Ri </i>) ≥ <i>F</i>(<i>Rj </i>)</div><div><span style="background-color: #ffdebd;">6.<b>Deadlock Avoidance</b></span></div><div style="padding-left:40px;"><b>-require additional information about how resources are to be requested.</b></div><div style="padding-left:80px;">-Simplest and most useful model requires that each process declare the  <b><i>maximum number</i></b>of resources of each type that it may need</div><div style="padding-left:80px;">-examines the <b>resource-allocation state</b> to  ensure that there can never be a circular-wait condition</div><div style="padding-left:80px;">-Resource-allocation <i>state</i>is defined by the number of available and allocated  resources, and the maximum demands of the processes</div><div style="padding-left:40px;">-<b>Safe State</b></div><div style="padding-left:80px;">System is in <b>safe state </b>if there exists a sequence &lt;<i>P1, P2, …, Pn</i>&gt; of ALL the   processes  in the systems such that  for each Pi, the resources that Pi can  still request can be satisfied by currently available resources + resources held  by all the <i>Pj</i>, with<i>j </i>&lt; <i>i</i></div><div style="padding-left:80px;"><i>-</i><b>Basic Facts</b></div><p style="padding-left:120px;">If a system is in safe state -》 no deadlocks</p><p style="padding-left:160px;">If a system is in unsafe state -》 possibility of deadlock</p><div style="padding-left:160px;">Avoidance -》 ensure that a system will never enter an unsafe state.</div><img src="CH7 Deadlocks_files/C5.png" type="image/png" data-filename="C5.png" width="214.50000000000003px"/><div style="padding-left:80px;">-<b>Avoidance Algorithms</b></div><div style="padding-left:80px;">1.Single instance of a resource type</div><div style="padding-left:120px;">use reource-allocated graph</div><div style="padding-left:80px;">2.multuple instances of a resoure type</div><div style="padding-left:120px;">banker's algorithm</div><div style="padding-left:80px;">-<b>Resource-Allocation Graph Scheme</b></div><div style="padding-left:120px;">-algorothm:    </div><div style="padding-left:160px;">Suppose that process<i>Pi </i>requests a resource <i>Rj</i></div><div style="padding-left:160px;">The request can be granted only if converting the request edge to an  assignment edge does <b>not </b>result in the formation of a <b>cycle </b>in the resource  allocation graph</div><div style="padding-left:80px;">-<b>Banker’s Algorithm</b></div><div style="padding-left:120px;">-Data Structures for Banker's Algorithm</div><div style="padding-left:160px;">n = number of processes, m = number of resource types</div><div style="padding-left:160px;"><b>-Available : </b>Vector of length m, if available[j] = k, there are k instances of resource type Rj available</div><div style="padding-left:160px;"><b>-Max:</b> NxM matrix, if Max[i,j] = k, the process Pi may request at most k instances of resource type Rj</div><div style="padding-left:160px;"><b>-Allocation: </b>NxM matrix, if Allocation[i,j] = k then Pi is currently allocated k instances of Rj</div><div style="padding-left:160px;"><b>-Need</b>: NxM matrix, matrix. If <i>Need</i>[<i>i,j</i>] =<i>k</i>, then<i>Pi</i>may need <i>k</i>more instances of <i>Rj</i>to complete its  task</div><div style="padding-left:240px;"><b><i>Need</i>[<i>i,j]</i>= <i>Max</i>[<i>i,j</i>] –<i>Allocation</i>[<i>i,j</i>]</b></div><div style="padding-left:160px;"><b>-Safety Algorithm</b></div><div style="padding-left:200px;"><b>1.</b>Let <b><i>Work</i></b>and <b><i>Finish</i></b>be vectors of length <i>m </i>and <i>n</i>, respectively.  Initialize</div><div style="padding-left:240px;">Work = Avaliable                               //available resource</div><div style="padding-left:240px;">Finish[i] = false for i = 0, 1, ..., ,n-1    //the process has finished</div><div style="padding-left:200px;">2.Find i s.t. both:</div><div style="padding-left:240px;">(a) Finish[i] = false;</div><div style="padding-left:240px;">(b) Needi&lt;=Work</div><div style="padding-left:240px;">if no such i , go to step 4</div><div style="padding-left:200px;">3.Work = Work + Allocationi;</div><div style="padding-left:240px;">Finish[i] = true;</div><div style="padding-left:240px;">go to step 2</div><div style="padding-left:200px;">4.if Finish[i] == true for all i, the system is in a safe state.</div><div style="padding-left:160px;">-<b>Resource-Request Algorithm for Process <i>Pi</i></b></div><div style="padding-left:200px;"><b><i>Requesti</i></b>= request vector for process <b><i>Pi</i></b>.  If <b><i>Requesti</i>[<i>j</i>] = <i>k</i></b>then process  <b><i>Pi</i></b>wants <b><i>k</i></b>instances of resource type <b><i>Rj</i></b></div><div style="padding-left:200px;"><b><i>1.</i></b>If <b><i>Requesti</i></b> &lt;= <b><i>Needi </i></b>go to step 2.  Otherwise, raise error condition, since  process has exceeded its maximum claim</div><div style="padding-left:200px;">2.If <b><i>Requesti</i></b> &lt;= <b><i>Available</i></b>, go to step 3.  Otherwise <b><i>Pi </i></b>must wait, since resources  are not available</div><div style="padding-left:200px;">3.</div><div style="padding-left:240px;"><b><i>Available </i>= <i>Available  </i>– <i>Requesti;</i></b></div><div style="padding-left:240px;"><b><i>Allocationi </i>= <i>Allocationi</i>+ <i>Requesti</i>;</b></div><div style="padding-left:240px;"><b><i>Needi </i>= <i>Needi </i>– <i>Requesti;</i></b></div><div><br/></div><div style="padding-left:240px;">If safe, resources are allocated to Pi</div><div style="padding-left:240px;">unsafe-&gt; Pi must wait, old resource-allocation state is recorded</div><div style="padding-left:160px;"><b>-Example of Banker</b>’<b>s Algorithm</b></div><div style="padding-left:200px;"><b>1.判断安全状态： </b>-<b>Need</b> &lt; available</div><div style="padding-left:320px;">      -Available = available +<b> allocation</b></div><div style="padding-left:320px;">全部P都完成才safe</div><div style="padding-left:200px;"><b>2.判断是否可以给request分配资源：</b></div><div style="padding-left:240px;">1.request&lt;<b>need</b></div><div style="padding-left:240px;">2.request&lt;<b>available</b></div><div style="padding-left:240px;">3.满足上两点，假设request被分配，</div><div style="padding-left:280px;"><i>Available</i> = <i>Available </i> – <i>Requesti;</i></div><div style="padding-left:240px;"><i>Allocationi</i> = <i>Allocationi</i>+ <i>Requesti</i>;</div><div style="padding-left:240px;"><i>Needi</i> = <i>Needi</i> – <i>Requesti;，</i></div><div style="padding-left:240px;"><i>4.再次检查是否安全，安全就可以分配</i></div><div><br/></div><div style="padding-left:40px;"><b>7.Deadlock Detection:</b></div><div style="padding-left:80px;">Allow system enter deadlock state</div><div style="padding-left:80px;">detect deadlock</div><div style="padding-left:80px;">recovery</div><div style="padding-left:80px;">-<b>Single Instance of Each Resource Type</b></div><div style="padding-left:120px;">Maintain <b>wait-for </b>graph</div><p style="padding-left:120px;">pNodes are processes</p><div style="padding-left:120px;">p<b><i>Pi</i></b>-&gt;<b><i>Pj</i></b>if <b><i>Pi</i></b>is waiting for<b><i>Pj</i></b></div><div style="padding-left:80px;"><b>Periodically</b>invoke an algorithm that searches for a <b>cycle</b>in the graph. If there  is a cycle, there exists a deadlock</div><div style="padding-left:80px;">-<b>Detection Algorithm</b></div><div style="padding-left:120px;"><b>1.</b><span style="background-color: #ffdebd;"><b>Work = available</b></span></div><div style="padding-left:160px;"><b>if allocation i 不等于 0, Finish[i] = false,   否则Finish[I] = true</b></div><div style="padding-left:120px;"><b>2.find i, </b></div><div style="padding-left:160px;"><b>Finish[i] = false</b></div><div style="padding-left:160px;"><span style="background-color: #ffdebd;"><b>request i &lt;= work</b></span></div><div style="padding-left:120px;"><b>3.</b><span style="background-color: #ffdebd;"><b>work = work + allocation</b></span></div><div style="padding-left:160px;"><b>Finish[i] = true, go to step 2</b></div><div style="padding-left:120px;"><b>4.Finish[i] == false, Pi is deadlocked</b></div><div style="padding-left:80px;"><b>=Example:</b></div><div style="padding-left:40px;"><b>8.Recovery from Deadlock:  Process Termination</b></div><div style="padding-left:80px;">1.Abort all deadlocked processes</div><div style="padding-left:80px;">2.Abort one process at a time until the deadlock cycle is eliminated</div><div style="padding-left:80px;"><b>Recovery from Deadlock:  Resource Preemption</b></div><p style="padding-left:120px;"><b>Selecting a victim</b>    <b> </b>–minimize cost</p><p style="padding-left:120px;"><b>Rollback</b>        –return to some safe state, restart process for that state</p><div style="padding-left:120px;"><b>Starvation</b>        –same process may always be picked as victim, include number  of rollback in cost factor(rollbackinafinitenumberoftimes)</div></span>
</div></body></html> 