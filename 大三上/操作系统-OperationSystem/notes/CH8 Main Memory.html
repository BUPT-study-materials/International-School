<html>
<head>
  <title>CH8 Main Memory</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602326 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="900"/>
<h1>CH8 Main Memory</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/12/18 15:18</i></td></tr>
<tr><td><b>作者：</b></td><td><i>dmadkr1217</i></td></tr>
</table>
</div>
<br/>

<div><span><h1>CH8 Main Memory</h1><div>1.<b>Background</b></div><p style="padding-left:40px;">Program must be brought (from disk)  into memory and placed within a  process for it to be run</p><p style="padding-left:40px;">Main<b> memory and registers</b> are only storage CPU can access <b>directly</b></p><p style="padding-left:40px;">Memory unit only sees a stream of addresses +read requests, or address +  data and write requests</p><p style="padding-left:40px;">Register access in <b>one </b>CPU clock cycle (or less)</p><p style="padding-left:40px;">Main memory can take <b>many </b>cycles, causing a <b>stall</b></p><p style="padding-left:40px;"><b>Cache</b>(on the CPU chip) sits between main memory and CPU registers</p><div style="padding-left:40px;">Protection of memory required to ensure correct operation</div><div>2.<b>Base and Limit Registers</b></div><p style="padding-left:40px;">A pair of <b>base </b>and <b>limit registers </b>define the logical address space</p><div style="padding-left:40px;">CPU must check every memory access generated<b> in user mode</b> to be sure it  is between base and limit for that user</div><img src="CH8 Main Memory_files/C6.png" type="image/png" data-filename="C6.png" width="522.0276497695853px"/><div>3.<b>Address Binding</b>    地址绑定</div><div style="padding-left:40px;">Programs on disk, ready to be brought into memory to execute,form an <b>input queue</b></div><div style="padding-left:40px;">addresses represented in different ways at different stages of a program’s life</div><div style="padding-left:40px;">The linkage editor or loader in turn <b>binds the relocatable addresses to absolute addresses </b></div><div style="padding-left:40px;">Each binding is a <b>mapping from one address space to another</b></div><div style="padding-left:40px;">three different stages：</div><p style="padding-left:40px;"><b>Compile time</b>:  If memory location known a priori, <b>absolute code </b>can be  generated; must recompile code if starting location changes</p><p style="padding-left:40px;"><b>Load time</b>:  Must generate <b>relocatable code </b>if memory location is not  known at compile time</p><div style="padding-left:40px;"><b>Execution time</b>:  Binding delayed until run time if the process can be  moved during its execution from one memory segment to another</div><img src="CH8 Main Memory_files/C7.png" type="image/png" data-filename="C7.png" width="516.5167464114833px"/><div style="padding-left:40px;"><b>4.Logical vs. Physical Address Space</b></div><div style="padding-left:80px;"> logical address space that is bound to a separate <b>physical  address space </b></div><div style="padding-left:80px;"><b>Logical address</b>–generated by the CPU; also referred to as <b>virtual address</b></div><div style="padding-left:80px;"><b>Physical address</b>–address seen by the memory unit</div><div style="padding-left:80px;">Logical and physical addresses are the same in compile-time and load-time  address-binding schemes; logical (virtual) and physical addresses differ in  execution-time address-binding scheme</div><div style="padding-left:80px;"><b>Logical address space </b></div><div style="padding-left:80px;"><b>Physical address space </b></div><div style="padding-left:40px;"><b>5.Memory-Management Unit (MMU)</b></div><div style="padding-left:80px;"><b>Hardware device</b> that at run time maps virtual to physical address</div><div style="padding-left:80px;">The user program deals with <i>logical</i>addresses; it never sees the <i>real</i>physical  addresses</div><p style="padding-left:120px;">Execution-time binding occurs when reference is made to location in memory</p><div style="padding-left:120px;">Logical address bound to physical addresses</div><div style="padding-left:80px;"><b>Dynamic relocation using a relocation register</b></div><div style="padding-left:40px;"><b>6.Dynamic Linking</b></div><div style="padding-left:80px;"><b>Static linking </b>–system libraries and program code combined by the loader  into the binary program image</div><div style="padding-left:80px;">Dynamic linking –linking postponed until execution time</div><p style="padding-left:40px;"><b>7</b>.<b>Swapping</b></p><div style="padding-left:80px;">A process can be <b>swapped </b>temporarily out of memory to a backing store, and  then brought back into memory for continued execution</div><div style="padding-left:80px;"><b>-Backing store</b>        </div><div style="padding-left:120px;">–<b>fast disk large</b> enough to contain copies of all memory  images for all users; must provide <b>direct access to these memory images</b></div><div style="padding-left:80px;"><b>-Roll out, roll in</b>        </div><div style="padding-left:120px;">–swapping variant used for priority-based scheduling  algorithms; lower-priority process is swapped out so higher-priority process  can be loaded and executed</div><div style="padding-left:80px;">-<b> transfer time;</b></div><div style="padding-left:80px;"><b>-ready queue,  for proceses have memory images on disk</b></div><img src="CH8 Main Memory_files/C8.png" type="image/png" data-filename="C8.png" width="465.3757009345794px"/><div style="padding-left:80px;"><br/></div><div style="padding-left:40px;"><b>8</b>.<b>Context Switch Time including Swapping</b></div><div style="padding-left:120px;"><b>-content switching time  </b>Can reduce if reduce size of memory swapped –by knowing how much  memory really being used</div><div style="padding-left:120px;">切换限制：    1.PendingI/O</div><div style="padding-left:240px;">2.Double buffering</div><div style="padding-left:120px;"> 现代：Swap only when free memory extremely low</div><div style="padding-left:40px;"><b>9.Swapping on Mobile Systems</b></div><div style="padding-left:80px;"><b>1.</b>Flash memory based</div><div style="padding-left:80px;">2.Instead use other methods to free memory if low</div><div style="padding-left:120px;">iOS <b><i>asks</i></b>apps to voluntarily relinquish allocated memory</div><div style="padding-left:120px;">Android terminates apps if low free memory, but first writes <b>application  state</b>to flash for fast restart</div><div style="padding-left:40px;"><b>10.Contiguous Allocation 连续内存访问</b></div><div style="padding-left:80px;">Main memory usually into two <b>partitions</b>:</div><p style="padding-left:120px;"><b>1.Resident operating system</b>, usually held in low memory with interrupt vector</p><p style="padding-left:120px;"><b>2.User processes</b> then held in high memory</p><div style="padding-left:160px;">Each process contained in single contiguous section of memory</div><div style="padding-left:120px;">Relocation registers ：</div><p style="padding-left:160px;"><b>Base register</b> contains value of smallest physical address</p><p style="padding-left:160px;"><b>Limit register</b> contains range of logical addresses –each logical address  must be less than the limit register </p><p style="padding-left:160px;"><b>MMU</b> maps logical address <i>dynamically</i></p><div style="padding-left:160px;">Can then allow actions such as kernel code being <b>transient </b>and kernel  changing size</div><div style="padding-left:40px;">11.<b>Multiple-partition allocation</b></div><div style="padding-left:80px;"><b>·定长分区:</b>把内存分成若干个大、中、小三个2等级，每个等级大小相同的区，每一个区分配给一个process，适用于多个相同进程的进行。</div><div style="padding-left:120px;">缺点：分区总数不可变，限制了并发程序数目；有内碎片</div><div style="padding-left:80px;">-动态长度分区：process需要多少，给一个大于等于需求的分区。没有内碎片，有外碎片。</div><p style="padding-left:80px;">Degree of multiprogramming limited by number of partitions</p><p style="padding-left:80px;"><b>Variable-partition </b>sizes for efficiency (sized to a given process’needs)</p><p style="padding-left:80px;"><b>Hole</b>–block of available memory; holes of various size are scattered throughout memory</p><p style="padding-left:80px;">When a process arrives, it is allocated memory from a hole large enough to  accommodate it</p><p style="padding-left:80px;">Process exiting frees its partition, adjacent free partitions combined</p><div style="padding-left:80px;">Operating system maintains information about:</div><div style="padding-left:120px;">a) allocated partitions    </div><div style="padding-left:120px;">b) free partitions  (hole)</div><img src="CH8 Main Memory_files/C9.png" type="image/png" data-filename="C9.png" width="335px"/><div><br/></div><div style="padding-left:40px;"><b>Dynamic Storage-Allocation Problem</b></div><div style="padding-left:80px;">How to satisfy a request of size <b><i>n</i></b>from a list of free holes?</div><div style="padding-left:120px;"><b>First-fit</b>:  Allocate the <b><i>first</i></b>hole that is big enough</div><div style="padding-left:120px;"><b>Best-fit</b>:  Allocate the <b><i>smallest</i></b>hole that is big enough; must search entire  list, unless ordered by size  </div><div style="padding-left:120px;"><b>Worst-fit</b>:  Allocate the <b><i>largest</i></b>hole; must also search entire list  </div><div style="padding-left:40px;"><span style="background-color: #ffdebd;"><b>12.Fragmentation（碎片)</b></span></div><div style="padding-left:80px;">原因：multiple-parition allocation在存储空间里留下了不连续的内存碎片，不足以支持一个allocation，浪费</div><div style="padding-left:80px;"><b>External Fragmentation</b> 外碎片   </div><div style="padding-left:120px;">As processes are loaded and removed from memory, the free memory space is broken into little pieces. External fragmentation exists when there is enough total memory space to satisfy a request but the available spaces are not contiguous: storage is fragmented into a large number of small holes.</div><div style="padding-left:80px;"><b>Internal Fragmentation</b>    内碎片</div><div style="padding-left:120px;"><b>-</b>break the physical memory into fixed-sized blocks, <b>allocated memory</b> may be  slightly <b>larger than requested memory</b>; this size difference is memory internal  to a partition, but not being used</div><div style="padding-left:80px;">-1/3 may be unusable -&gt; <b>50-percent rule</b></div><div style="padding-left:80px;">-Reduce external fragmentation by <b>compaction</b></div><div style="padding-left:120px;">place all free memory together in one large block</div><div style="padding-left:120px;">Compaction is possible <i>only</i>if relocation is <b>dynamic</b>, and is done at execution  time</div><div style="padding-left:40px;"><span style="background-color: #ffdebd;"><b>13.Segmentation(分段）</b></span></div><div style="padding-left:80px;"><b>Reason</b>:provide a memory mechanism that mapped the programmer’s view to the actual physical memory</div><div style="padding-left:80px;">A program is a collection of segments</div><div style="padding-left:80px;">A segment is a logical unit</div><div style="padding-left:80px;"><b>-Segmentation Architecture </b></div><div style="padding-left:120px;">Logical address consists of a two tuple:<b>&lt;segment-number, offset&gt;,</b></div><div style="padding-left:120px;"><b>Segment table</b>    –maps two-dimensional physical addresses;</div><div style="padding-left:120px;"> each table entry  has:</div><p style="padding-left:160px;"><b>base</b>–contains the starting physical address where the segments reside in  memory</p><div style="padding-left:160px;"><b>limit</b>–specifies the length of the segment</div><div style="padding-left:120px;"><b>Segment-table base register (STBR)</b>points to the segment table’s location in  memory</div><div style="padding-left:120px;"><b>Segment-table length register (STLR)</b>indicates number of segments used  by a program;</div><div style="padding-left:160px;">segment number <b><i>s</i></b>is legal if <b><i>s</i></b>&lt;= <b>STLR</b></div><div style="padding-left:120px;">-Protection</div><div style="padding-left:160px;">With each entry in segment table associate：</div><div style="padding-left:200px;">validation bit 0 -&gt; illegal segment</div><div style="padding-left:200px;">read.write/execute privileges</div><img src="CH8 Main Memory_files/D1.png" type="image/png" data-filename="D1.png" width="457.2946635730858px"/><img src="CH8 Main Memory_files/D2.png" type="image/png" data-filename="D2.png" width="477px"/><div style="padding-left:40px;"><span style="background-color: #ffdebd;"><b>14.Paging 分页</b></span></div><div style="padding-left:80px;">Physical  address space of a process can be noncontiguous; process is  allocated physical memory whenever the latter is available</div><div style="padding-left:80px;">Divide physical memory into fixed-sized blocks called <b>frames</b></div><div style="padding-left:120px;">Size is power of 2, between 512 bytes and 16 Mbytes</div><div style="padding-left:80px;">Divide logical memory into blocks of same size called <b>pages</b></div><div style="padding-left:80px;">Set up a <b>page table</b>to translate logical to physical addresses</div><div style="padding-left:80px;">Back store split into pages</div><div style="padding-left:80px;">still have internal fragmentation</div><div style="padding-left:40px;"><b>Address Translation Scheme</b></div><div style="padding-left:80px;"><b>virtual address is divided into:</b></div><div style="padding-left:80px;"><b>1.Page number(p)</b>    -use as an<b> index</b> into a page table which contains base address of each page in physical memory</div><div style="padding-left:80px;"><b>2.Page offset(d) </b>   -combined with base address to define the physical address</div><div style="padding-left:80px;">For given<b> logical address space 2<i>^m</i></b><i> </i>and <b>page size<i>2</i>^n,</b></div><div style="padding-left:120px;">p = m-n</div><div style="padding-left:120px;">d = n</div><img src="CH8 Main Memory_files/C1.png" type="image/png" data-filename="C1.png" width="514.7342799188641px"/><img src="CH8 Main Memory_files/C2.png" type="image/png" data-filename="C2.png" width="504px"/><div><br/></div><img src="CH8 Main Memory_files/C3.png" type="image/png" data-filename="C3.png" width="355px"/><div style="padding-left:80px;">page sizetoday, between 4kb and 8kb</div><div style="padding-left:40px;"><span style="background-color: #ffdebd;"><b>15.Implementation of Page Table</b></span></div><div style="padding-left:80px;"><b>页表在主存里</b></div><div style="padding-left:80px;"><b>Page-table base register </b>(<b>PTBR</b>)points to the page table</div><div style="padding-left:80px;"><b>Page-table length register </b>(<b>PTLR</b>)indicates size of the page table</div><div style="padding-left:80px;">-fast-lookup hardware cache</div><div style="padding-left:120px;">解决： every data/instruction access requires two memory accesses</div><div style="padding-left:120px;">associative memory / <b>translation look-aside buffers(TLB) 地址变换高速缓存</b></div><div style="padding-left:120px;">TLBs store <b>address-space identifiers</b>(ASIDs) in each TLB entry</div><div style="padding-left:120px;">TLBs typically small(64 to 1,024 entrys)</div><div style="padding-left:120px;">On a TLB miss, value is loaded into TLB for faster access next time</div><div style="padding-left:80px;">-Associative Memory</div><div style="padding-left:80px;">Page&lt;-&gt;Frame, address translation(p,d)</div><div style="padding-left:120px;">if p is in TLB, get frame out</div><div style="padding-left:120px;">otherwise get frame from page table in memory</div><img src="CH8 Main Memory_files/C4.png" type="image/png" data-filename="C4.png" width="481.5410199556541px"/><div><br/></div><div style="padding-left:40px;"><b>16.Effective Access Time(EAT)</b></div><div style="padding-left:80px;">Associative Lookup = lamda time unit</div><div style="padding-left:80px;">Hit ratio = a</div><div style="padding-left:120px;">Hit ratio –percentage of times that a page number is found in the associative  registers; ratio related to number of associative registers</div><div style="padding-left:80px;"><b>Effective Access Time</b>(<b>EAT</b>)</div><div style="padding-left:120px;">EAT = (1*memory reference time + TLB search time) * hit_rate+ (2*memory reference time + TLB search time)*(1 –hit_rate)</div><div style="padding-left:80px;">Consider a= 80%, e= 20ns for TLB search, 100ns for memory access</div><div style="padding-left:120px;">EAT = 0.80 x 120 + 0.20 x 220 = 140ns (2*100+20-80 = 140ns）</div><div style="padding-left:40px;"><b>17.Valid（v) or invalid(i) Bit in A Page Table</b></div><div style="padding-left:80px;">One additional bit is generally attached to each entry in the page table: a <b>valid–invalid </b>bit. When this bit is set to <i>valid, </i>the associated page is in the process’s logical address space and is thus a legal (or valid) page. When the bit is set to<i>invalid, </i>the page is not in the process’s logical address space. Illegal addresses are trapped by use of the valid–invalid bit.</div><div style="padding-left:40px;"><b>18.Shared Pages</b></div><div style="padding-left:80px;"><b>-Shared code</b></div><div style="padding-left:120px;"><b>One copy</b> of read-only(reentrant) code shared among processes</div><div style="padding-left:120px;">Similar to multiple threads sharing same process space</div><div style="padding-left:120px;">usefun for interprocess comunication</div><div style="padding-left:80px;"><b>-Private code and data</b></div><p style="padding-left:120px;">E<b>ach process keeps a separate copy</b> of the code and data</p><div style="padding-left:160px;">The pages for the private code and data can appear anywhere in the logical  address space</div><div style="padding-left:40px;"><b>19.Structure of the Page Table</b></div><div style="padding-left:80px;">Memory structures for paging can get huge using straight-forward methods</div><div style="padding-left:120px;">Consider a 32-bit logical address space as on modern computers</div><div style="padding-left:120px;">Page size of 4KB(2^12)</div><div style="padding-left:120px;">Page table would have 1million entries(2^32/2^12)</div><div style="padding-left:120px;">if each entry is 4 bytes, -&gt; 4MB of physical address space for page table alone</div><div style="padding-left:160px;">cost a lot</div><div style="padding-left:80px;">因此：</div><p style="padding-left:160px;">Hierarchical Paging</p><p style="padding-left:160px;">Hashed Page Tables</p><div style="padding-left:160px;">Inverted Page Tables</div><div style="padding-left:80px;">1.<b>Hierarchical Page Tables</b></div><div style="padding-left:120px;">break logical affress space into multiple page tables</div><div style="padding-left:120px;">-two-level page table</div><div style="padding-left:120px;">page the page table</div><div style="padding-left:80px;">2.<b>Two-Level Paging Example(32-bit)</b></div><div style="padding-left:120px;"><b>-forward-mapped page table</b></div><div style="padding-left:120px;">A logical address(<b>on 32-bit machine</b> with 4KB page zise) is divided into:</div><div style="padding-left:160px;">-a page number consisting of 20 bits</div><div style="padding-left:200px;">-a 10-bit page number</div><div style="padding-left:200px;">-a 10-bir page offset</div><div style="padding-left:160px;">-a page offset cnsisting of 12 bits</div><img src="CH8 Main Memory_files/C5.png" type="image/png" data-filename="C5.png" width="480.25130890052355px"/><div><br/></div><div style="padding-left:80px;">3.<b>64-bit Logical Address Space(Hashed Page Tables)</b></div><div style="padding-left:80px;"><b>-two level not suficient -&gt; use Hashed Page Tables</b></div><div style="padding-left:120px;">The virtual page number is hashed into a page table</div><div style="padding-left:120px;">Each element contains:</div><div style="padding-left:160px;">1.The virtual page number</div><div style="padding-left:160px;">2.the value of mapped page frame</div><div style="padding-left:160px;">3.a pointer to next </div><div style="padding-left:80px;">-Variation for 64-bit address:<b> clustered page tables</b></div><div style="padding-left:120px;">each entry refers to several pages rather than 1</div><div style="padding-left:120px;">useful for sparse address spaces</div><img src="CH8 Main Memory_files/C6 [1].png" type="image/png" data-filename="C6.png" width="418px"/><div style="padding-left:80px;">4.<b>Inverted Page Table</b></div><div style="padding-left:120px;">基于哈希表，查找frame，然后查找其对应的虚拟地址（之前的方法查找虚拟地址然后对应frame）</div><div><b>20.Example: The Intel 32 and 64-bit Architectures</b></div><div style="padding-left:40px;">Supports both segmentation and segmentation with paging</div><p style="padding-left:80px;">Each segment can be 4 GB</p><p style="padding-left:80px;">Up to 16 K segments per process</p><div style="padding-left:80px;">Divided into two partitions</div><p style="padding-left:120px;">First partition of up to 8 K segments are private to process (kept in <b>local  descriptor table </b>(<b>LDT</b>))</p><div style="padding-left:120px;">Second partition of up to 8K segments shared among all processes (kept in  <b>global descriptor table </b>(<b>GDT</b>))</div><div style="padding-left:40px;">CPU generates logical address</div><div style="padding-left:80px;">Selector given to segmentation unit</div><div style="padding-left:120px;">Which produces <b>linear addresses </b></div><div style="padding-left:80px;">Linear address given to paging unit</div><p style="padding-left:120px;">Which generates physical address in main memory</p><p style="padding-left:120px;">Paging units form equivalent of MMU</p><div style="padding-left:120px;">Pages sizes can be 4 KB or 4 MB</div><img src="CH8 Main Memory_files/C7 [1].png" type="image/png" data-filename="C7.png"/><img src="CH8 Main Memory_files/C8 [1].png" type="image/png" data-filename="C8.png"/><img src="CH8 Main Memory_files/C9 [1].png" type="image/png" data-filename="C9.png"/><img src="CH8 Main Memory_files/C10.png" type="image/png" data-filename="C10.png"/><div><br/></div></span>
</div></body></html> 