<html>
<head>
  <title>CH9 Virtual Memory</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602326 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="769"/>
<h1>CH9 Virtual Memory</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/11/26 15:53</i></td></tr>
<tr><td><b>作者：</b></td><td><i>dmadkr1217</i></td></tr>
</table>
</div>
<br/>

<div><span><h2>CH9 Virtual Memory</h2><h1>20201126 W11L2</h1><h2>Review CH9 Virtual Memory</h2><div><br/></div><h2>9.1 虚拟内存：</h2><h3>为什么需要虚拟内存？</h3><div>Answer：<b> 1.entire program is not needed</b></div><div style="padding-left:80px;"> 1.error handling的代码 2.array，list，tables请求过大的内存，然而没有真正被使用 3.可选的功能和attributes极少被使用</div><div style="padding-left:80px;"><b>2.就算整个程序都有用，不一定在所有时候他们都有用</b></div><div>虚拟内存的好处：</div><div style="padding-left:80px;">1.programs no longer constrained by amount of virtual memory</div><div style="padding-left:80px;">2.each program takes less memory, more programs could run at same time</div><div style="padding-left:80px;">3.less I/O</div><h3>虚拟内存的作用/用处：</h3><div><b>1.separation of logical memory from physocal memory</b></div><div style="padding-left:40px;">an extremely large virtual memory to be provided for programmers when only a smaller physical memory is available</div><div style="padding-left:40px;">方法：Mapping logical memory to physical memory by MMU(memory management unit)</div><div><b>2.two or more processed share library using virtual memory</b></div><div style="padding-left:40px;">shared pages 被 mapping到虚拟内存里，真实的物理页可以被多个进程共享</div><div style="padding-left:40px;">fork()</div><div style="padding-left:40px;"><br/></div><h2>9<span style="background-color: #ffdebd;">.2 虚拟内存的实现：Demand Paging 请求分页</span></h2><div style="padding-left:40px;"><span style="background-color: #ffdebd;"><b>”load pages only as they are needed“</b></span></div><div>pages are loaded only when they are demanded during program execution by <span style="color: #40609C;"><b>pager</b></span></div><div style="padding-left:40px;"> 使用valid-invalid bit来区分page在内存中还是在disc中。</div><div style="padding-left:40px;">“valid”：page is legal and in memory</div><div style="padding-left:40px;">&quot;invalid&quot;: not valid/valid but now on disc</div><h3>Page fault: </h3><div>    access to a page marked invalid</div><div style="padding-left:40px;">1.check internal table to identify if the reference was valid or invalid</div><div style="padding-left:40px;">2.valid-&gt;page in invalid-&gt;process terminated</div><div style="padding-left:40px;">3.after terminate, causing a OS trap, OS will find a free frame</div><div style="padding-left:40px;">4.schedule a disk operation to read the desired pge into the new frame</div><div style="padding-left:40px;">5.modify internal table as the page is valid</div><div style="padding-left:40px;">6.restart the instruction</div><img src="CH9 Virtual Memory_files/D1.png" type="image/png" data-filename="D1.png" width="423.8263772954925px"/><div><b>pure demand paging</b>：never bring a page into memory until its required</div><div><b>hard wares:</b></div><div style="padding-left:40px;">1.Page table: mark an entry with valid-invalid bit/protection bits</div><div style="padding-left:40px;">2.Secondary memory: 存放不在内存里的page，通常是high-speed disk，也被记为swap device with <b>swap space</b></div><div style="padding-left:40px;"><b>3.instruction restart</b></div><div>Demandpaging需要保证</div><div style="padding-left:40px;">restart any instruction after a page fault. exactly in the same place and state</div><div style="padding-left:40px;">*在instrcution过程中出现page fault，需要在get desired page后改正page table， </div><div style="padding-left:40px;">然后从头重新开始中各instruction，包括fetch instruction again，fetch operands again。。。。</div><h2></h2><h2>虚拟内存的性能</h2><div style="padding-left:40px;"><b>Effective access time</b> = (1-p)X memory access + p X page fault time</div><div style="padding-left:40px;">page fault rate 0&lt;=p&lt;=1, if p = 0 no page faults, p = 1, every reference is fault</div><div><b>中断驱动的一般过程</b></div><div><b>A page fault causes the following sequence to occcr:</b></div><div style="padding-left:40px;">1.Trap to the operating system(drop from user mode to 最底层的 kernel mode ）</div><div style="padding-left:40px;">2.save user registers and process state</div><div style="padding-left:40px;">3.determine that the interrupt was a page fault(缺页中断）</div><div style="padding-left:40px;">4.check that the page reference was legal and determine the location of the page on the disk</div><div style="padding-left:40px;">5.Issue a read from the disk to a free frame</div><div style="padding-left:80px;">a. Wait in a queue for this device until the read request is services</div><div style="padding-left:80px;">b.Wait for the device seek and/or latency time</div><div style="padding-left:80px;">c.Begin the transfer of the page to a free frame</div><div style="padding-left:40px;">6.等待过程中允许中断，CPU分配给其他user</div><div style="padding-left:40px;">7.收到interrupt from disc I/O system,磁盘访问完毕后会有一次中断</div><div style="padding-left:40px;">8.save the registers and process state for the other user</div><div style="padding-left:40px;">9.determine that the interrupt was from the disk</div><div style="padding-left:40px;">10.Correct the page table and other tables to show that the desired page is now in memory</div><div style="padding-left:40px;">11.wait for the CPU to be allocated to this process again</div><div style="padding-left:40px;">12.restore user registers,process state, new page table, then resume the interrupted instruction</div><div><br/></div><div>以上总结：</div><div>1.处理缺页中断</div><div>2.读入page</div><div>3.重启进程</div><div><br/></div><div>P407 // 1 milliseconds = 10^6nanoseconds</div><h2>swap space 交换空间</h2><div>1.Disk I/O(swap space I/O) faster than file I/O </div><div style="padding-left:40px;">swap allocated in larger chunks, less management needed than file system</div><div>2.Copy entire process image to swap space at process load time</div><div style="padding-left:40px;">older BSD Unix</div><div>3.demand page in from program binary on disk, but discard rather than paging out when freeing frame</div><div style="padding-left:40px;">Solaris/current BSD</div><div style="padding-left:40px;">still write to swap space的特殊情况：</div><div style="padding-left:40px;">1.pages not associated with a file(stack and heap) ——anoymous memory</div><div style="padding-left:40px;">2.pages modified in memory but not yet written back to the file system</div><div>4.mobile systems</div><div style="padding-left:40px;">dont support swapping</div><div style="padding-left:40px;">demand page from file system and reclaim read-only pages</div><div><br/></div><h2>9.3 Copy-on-Write</h2><div style="padding-left:40px;">allowing the parent and child process initially to share the same pages.</div><div style="padding-left:40px;">(用来替代复制整个parent进程的fork（），因为大部分被复制的进程没用）</div><div style="padding-left:40px;">OS 会创建父子共享的页中某一页的复制，把这个复制的address space mapping到紫禁城上，子进程会modify这个copied page。 </div><div style="padding-left:40px;">复制页来源于一个pool of free pages。</div><div style="padding-left:40px;">free page被分配复制前会经过<b>zero-fill-on-demand,意思是erasing the previous contents</b></div><div><br/></div><div style="padding-left:40px;">*vfork（）：调用该命令时parent暂停，child使用parent的地址空间，child做出的修改对parent可见，必须保证child不可以修改parent的地址空间。使用vfork时必须在建立child后立刻call exec（）</div><div><br/></div><h2><span style="background-color: #ffdebd;">9.4 Page Replacemen</span>t 页面置换算法</h2><div style="padding-left:40px;">over-allocation，when a page default occurs, all memory is use.</div><div style="padding-left:40px;">Use <b>modify </b>(<b>dirty</b>) <b>bit </b>to reduce overhead of  page transfers – only modified pages are written to  disk</div><div style="padding-left:40px;">OS should swap out a process, freeing all its frames and reducing the level of</div><div style="padding-left:40px;">multiprogramming,which is<b> page replacement</b></div><div style="padding-left:40px;">需要调入页面到内存中，但此时内存已满，就需要从内存中按照一定的置换算法决定将哪个页面取出将内存给调入的页面</div><img src="CH9 Virtual Memory_files/D2.png" type="image/png" data-filename="D2.png" width="455.4px"/><h3>9.4.1 basic page repalcement</h3><div>page-replacement algorithms</div><div><b>1.FIFO</b></div><div style="padding-left:40px;">always retirve the active page, <b>increase page-fault rate</b> and <b>slows process execution</b></div><div style="padding-left:40px;"><b>Velady's anomaly</b>:</div><div style="padding-left:40px;">the page-fault rate may <b><i>increase </i></b>as the number of <b>allocated frames increases.</b></div><div><b>2.Optimal Page Replacement（看后)</b></div><div style="padding-left:40px;">the algorithm that has the<b> lowest page-fault rate</b> of all algorithms and will <b>never suffer</b> from Belady’s anomaly.</div><div style="padding-left:40px;">Also called OPT or MIN.</div><div style="padding-left:40px;">&quot;<b> Replace the page that will not be used for the longest period of time&quot;</b></div><div style="padding-left:40px;">看队列里已有的数字哪一个在最长的时间后才会被使用</div><img src="CH9 Virtual Memory_files/D3.png" type="image/png" data-filename="D3.png" width="430px"/><div><b>3.LRU Page Replacement(least recently used)(看前）</b></div><div style="padding-left:40px;">replace the page that <b><i>has not been used </i></b>for the longest period of time. </div><div style="padding-left:40px;">实现方法：</div><div style="padding-left:40px;">1.counters，记录the time of the last reference of each page</div><div style="padding-left:40px;">2.Stack 被调用过的就放在栈顶，总是替换bottom的page</div><div style="padding-left:40px;"><b>stack algorithms</b></div><img src="CH9 Virtual Memory_files/D4.png" type="image/png" data-filename="D4.png" width="416px"/><div><b>4.LRU-Approximation Page Replacement</b></div><div style="padding-left:40px;">use reference bit </div><div style="padding-left:40px;">initial, all bits are cleared to 0 by OS, once referenced, set to 1 by hardware</div><div style="padding-left:40px;"><b>Additional-Reference-Bits Algorithm</b></div><div style="padding-left:40px;">for each page into the high-order bit of its 8-bit byte, shifting the other bits right by 1 bit and discarding the low-order bit.</div><div style="padding-left:40px;">未被使用：00000000</div><div style="padding-left:40px;">在每个周期中至少使用一次的页的移位寄存器值为11111111</div><div style="padding-left:40px;">数字越大，被使用越频繁，数字最小的会被replace。</div><div style="padding-left:40px;">如果所有page的数字一样小，使用FIFO</div><div style="padding-left:40px;"><b>4.2</b> <b>Second-Chance Algorithm</b></div><div style="padding-left:40px;">When a page gets a second chance, its reference bit is cleared, and its arrival time is reset to the current time. </div><div style="padding-left:40px;">实现：</div><div style="padding-left:40px;">使用双向链表实现一个循环队列寻找victim，若reference bit = 1，跳过并设置成0，然后前进，若reference bit = 0，replace it并在原位置插入一个新的page</div><div style="padding-left:40px;"><b>4.3</b> <b>Enhanced Second-Chance Algorithm</b></div><div style="padding-left:40px;">ordered pair (reference, modify)</div><div style="padding-left:40px;">（0，0）没用过也没修改过 最适合replace的</div><div style="padding-left:40px;">（0，1）没用过但是修改过，replace前需要先written</div><div style="padding-left:40px;">（1，0）最近使用过，有可能再次使用</div><div style="padding-left:40px;">（1，1）最近使用过也修改过。</div><div style="padding-left:40px;">和其他算法的区别：我们优先选择那些已经修改过的页面，以便减少所需的I/Os数量。</div><div><b>5.Counting-Based Page Replacement</b></div><div style="padding-left:40px;"><b>LFU：least frequently used</b></div><div style="padding-left:80px;">problem：however, when a page is used heavily during the initial phase of a process but then is never used again.</div><div style="padding-left:80px;">solution：一种解决方案是定期将计数右移1位，形成指数衰减的平均使用计数。（shift the counts right by 1 bit at regular intervals, forming an <b>exponentially decaying average usage count</b>）</div><div style="padding-left:40px;"><b>MFU: most frequently used</b></div><div style="padding-left:80px;">有些数据应用/数据库更倾向于阅读时间长的page</div><div><b>6. Page-Buffering Algorithms</b></div><div style="padding-left:40px;">keep a pool of free frames.</div><div style="padding-left:40px;">the desired page is read into a free frame from the pool before the victim is written out. 提前把desired page放入frame pools，在把victim替换出来之前就可以使用page。</div><div style="padding-left:40px;">实现：书445</div><div style="padding-left:40px;">Used in VAX/VMS system</div><div style="padding-left:80px;">When the FIFO replacement algorithm mistakenly replaces a page that is still in active use, that page is quickly retrieved from the free-frame pool, and no I/O is necessary. </div><div style="padding-left:40px;">Used in UNIX with Second-Chance Algorithm</div><div style="padding-left:80px;">reduce the penalty incurred if the wrong victim page is selected.</div><div>7.applications </div><div style="padding-left:40px;">raw disk</div><div><br/></div><h2>9.5 Allocation of Frames</h2><div>user process is allocated any free frame.</div><div><b>1.Minimun Number of Frames</b></div><div style="padding-left:40px;">we need at least one frame for the instruction and one frame for the memory reference.</div><div style="padding-left:40px;">wemust place a limit on the levels of indirection, set count to16 at the initialization,the counter is then decremented for each successive indirection for this instruction.</div><div style="padding-left:40px;">Whereas the minimum number of frames per process is defined by the architecture, the maximum number is defined by the amount of available physical memory. </div><div><b>2.Allocation Algorithms</b></div><div style="padding-left:40px;"><b>2.1 equal allocation/fixed allocation</b></div><div style="padding-left:80px;"><b>ai = allocation for pi = si/S x m</b></div><div style="padding-left:40px;"><b>2.2 proprtional allocation</b></div><div style="padding-left:80px;">according to size ,  按比例分配</div><div style="padding-left:80px;">the allocation may vary according to the multiprogramming level. If the multiprogramming level is increased, each process will lose some frames to provide the memory needed for the new process.</div><div style="padding-left:40px;">问题：没有考虑优先级</div><div style="padding-left:40px;">解决方案：Use a <b>proportional allocation</b> scheme using  priorities rather than size or use both size and priority</div><div><b>3.Global versus Local Allocation</b></div><div style="padding-left:40px;"><b>global replacement</b></div><div style="padding-left:80px;">select replacement from the set of all frames, one process can take a frame from another</div><div style="padding-left:80px;">优点：从全局系统寻找replacement，更有效率</div><div style="padding-left:80px;">问题：page fault rate同时取决于自己的性能和其他进程的性能，同个进程的性能可能差别很大</div><div style="padding-left:40px;"><b>local replacement</b></div><div style="padding-left:80px;">select from only<b> its own set of allocated frames.</b></div><div style="padding-left:80px;">优点：More consistent per-process performance（<b>性能表现更一致</b>）</div><div style="padding-left:80px;">问题：less used pages of memory</div><div><b>4.Non-Uniform Memory Access</b></div><div style="padding-left:40px;">背景：a given CPU can access some sections of main memory faster than it can access others</div><div style="padding-left:40px;">.对多cpu来说不同的进程对不同的page访问速度不同，平均分配的free frame不能满足需求</div><div style="padding-left:40px;"><b>NUMA（non-uniform memory access) systems:</b></div><div style="padding-left:80px;">have memory frames allocated “as close as possible” to the CPU, with lowest latency</div><div style="padding-left:40px;">实现方法：</div><div style="padding-left:80px;"><b>having the scheduler track the last CPU on which each process ran.</b></div><div style="padding-left:40px;">lgroups by Solaris：</div><div style="padding-left:80px;">latency groups</div><div style="padding-left:80px;">结构来跟踪CPU /内存低延迟组</div><div style="padding-left:80px;">用shcedule和分页器</div><div style="padding-left:80px;">在可能的情况下，调度一个进程的所有线程，并在lgroup中为该进程分配所有内存</div><div><br/></div><h2><span style="background-color: #ffdebd;">9.6 Thrashing 抖动</span></h2><div style="padding-left:40px;">原因：进程没有足够的frame来支持正在使用的page，会频繁发生page-fault</div><div style="padding-left:40px;">This high paging activity is called <b>thrashing</b>. A process is thrashing if it is spending more time paging than executing.</div><div><b>1.cause of Thrashing</b></div><div style="padding-left:40px;">操作系统想提高CPU利用率，当利用率低的时候会提升degree of multiprogramming, 新的进程如果没有足够的free frame会从正在运行的进程中抢夺frame，但这样CPU利用率就更低，造成恶性循环</div><div style="padding-left:40px;">解决方案：</div><div style="padding-left:80px;">local replacement algorithm</div><div style="padding-left:80px;">缺点；如果进程没有抖动，EAT也会降低</div><div style="padding-left:40px;">合理的解决思路：</div><div style="padding-left:80px;">To prevent thrashing, we must<b> provide a process with as many frames as it needs.</b></div><div style="padding-left:80px;">如何知道“needs”？：<b>locality model</b> following</div><div><b>2.working-Set Model</b></div><div style="padding-left:40px;"><b>delta（三角形）：working-set window</b></div><div style="padding-left:40px;">The idea is to examine th<b>e most recent delta page</b> references.</div><div style="padding-left:40px;">If a page is in active use, it will be in the working set. If it is no longer being used, it will drop from the working set ! time units after its last reference.</div><div style="padding-left:80px;"><i>D </i>=<i>WSSi (working set for process Pi)</i>之和</div><img src="CH9 Virtual Memory_files/D1 [1].png" type="image/png" data-filename="D1.png" width="330.2245989304813px"/><div style="padding-left:40px;">If the total demand is greater than the <b>total number of available frames</b> (<i>D</i>&gt; <i>m</i>), thrashing will occur, because some processes will not have enough frames.</div><div style="padding-left:40px;">OS监视每一个进程的working set，并分配给每个working set足够多的frame。如果free frame足够，会初始化新的进程，如果workingset大小增加导致free frame不足，OS会选择一个进程暂停他，并把他的frame分配给其他进程</div><div style="padding-left:40px;">实现的难点：keep track of the working set</div><div style="padding-left:40px;">解决方式：a fixed-interval timer interrupt and a reference bit.在中断时扫描所有的page，使用的为on，没使用的为off</div><div style="padding-left:80px;">Pages with at least one bit on will be in the working set.</div><div><b>3.Page-fault Frequency(PFF)</b></div><div style="padding-left:40px;">设置一个desired page-fault rate upper and lower bounds,如果高于上界就给进程新分配一个frame，如果低于下界就给进程移除一个frame。如果没有足够的frame来添加就从<b>低page fault rate</b>的进程里移除，分配给<b>高pagefault rate</b>的进程</div><div style="padding-left:40px;">Peaks and valleys over time：Apeak in the page-fault rate occurswhenwe begindemand-paging a new locality. However, once the working set of this new locality is in memory, the page-fault rate falls</div><img src="CH9 Virtual Memory_files/D2 [1].png" type="image/png" data-filename="D2.png" width="402px"/><h2>9.7 Memory-Mapped Files</h2><div>      <b>memory mapping</b>afile,allowsapartof thevirtualaddress space tobe logically associated with the file</div><div style="padding-left:40px;">原理：by mapping a disk block to a page (or pages) in memory.</div><div style="padding-left:40px;">允许多个进程通过mapping file共享文件，physical memory里的mapping file对应disk内的文件（是disk文件的copy）</div><div style="padding-left:40px;">看456/457的FIG9.22 9.23好理解</div><img src="CH9 Virtual Memory_files/D3 [1].png" type="image/png" data-filename="D3.png" width="466px"/><h2>9.8 Allocating Kernel Memory</h2><div style="padding-left:40px;">Treated differently from user memory</div><div style="padding-left:40px;"> Often allocated from a <b>free-memory pool</b></div><div style="padding-left:80px;">p Kernel requests memory for structures of<b>  varying sizes</b>（如果user mode进程请求1b，也会提供完整的一页）</div><div style="padding-left:80px;">p Some kernel memory needs to be contiguous（一些硬件设备要求物理连续的页）</div><div style="padding-left:40px;"><b>1.Buddy System：解决外碎片</b></div><div style="padding-left:80px;"><b>use a power-of-2 allocator 2,4,8,16......</b></div><div style="padding-left:80px;">For example, a request for 11 KB is satisfied with a 16-KB segment.</div><div style="padding-left:80px;">The segment is initially divided into two <b>buddies </b>FIg9.26 P461</div><img src="CH9 Virtual Memory_files/D4 [1].png" type="image/png" data-filename="D4.png" width="280px"/><div style="padding-left:80px;"><b>coalescing:buddies </b>可以快速聚合成segments</div><div style="padding-left:80px;">缺点：In fact, we cannot guarantee that less than<b> 50 percent （internal fragmentation的问题）</b>of the allocated unit will be wasted due to internal fragmentation.</div><div style="padding-left:40px;"><b>2.Slab Allocation：解决内碎片</b></div><div style="padding-left:40px;">A <b>slab </b>is made up of one or more physically contiguous pages.</div><div style="padding-left:40px;">A <b>cache </b>consists of one or more slabs. </div><div style="padding-left:40px;">使用多少分配多少</div><div style="padding-left:40px;">Benefits ：include no fragmentation, fast memory  request satisfaction</div><div style="padding-left:40px;">P462 Fig9.27</div><div style="padding-left:40px;">slab in linux看ppt即可</div><h2>9.9 Other Considerations</h2><div style="padding-left:40px;"><b>1 Prepaging</b></div><div style="padding-left:80px;">To reduce the large number of page faults that  occurs at process startup</div><div style="padding-left:80px;">Prepage all or some of the pages a process will  need, <b>before they are referenced</b></div><div style="padding-left:80px;">But if prepaged pages are unused, I/O and memory  was wasted</div><div style="padding-left:80px;">Assume <i>s </i>pages are prepaged and <i>α </i>of the pages  is used(0 ≤<i>α</i> ≤ 1).</div><div style="padding-left:80px;">If <i>α</i> is close to 0, prepaging loses; if <i>α</i> is close to 1, prepaging wins.</div><div style="padding-left:40px;"><b>2 Page Size</b></div><div style="padding-left:80px;">Page size selection must take into  consideration:</div><div style="padding-left:120px;">Fragmentation</div><div style="padding-left:120px;">Page table size</div><div style="padding-left:120px;"><b>Resolution</b></div><div style="padding-left:120px;">I/O overhead</div><div style="padding-left:120px;">Number of page faults</div><div style="padding-left:120px;">Locality</div><div style="padding-left:120px;"> TLB size</div><div style="padding-left:80px;">Always power of 2, usually in the<b> range 2^12  (4,096 bytes) to 2^22 (4,194,304 bytes)</b></div><div style="padding-left:80px;">On average, growing over time</div><div style="padding-left:40px;"><b>3</b> <b>Other Issues – TLB Reach</b></div><div style="padding-left:80px;">TLB Reach - The amount of memory accessible from  the TLB</div><div style="padding-left:80px;"><b>TLB Reach = (TLB Size) X (Page Size)</b></div><div style="padding-left:80px;">Ideally, the working set of each process is  stored in the TLB</div><div style="padding-left:80px;">Increase the Page Size</div><div style="padding-left:120px;">This may lead to an increase in fragmentation as  not all applications require a large page size</div><div style="padding-left:80px;">Provide Multiple Page Sizes</div><div style="padding-left:120px;">allows applications that require larger page  sizes the opportunity to use them without an increase in  fragmentation</div><div style="padding-left:40px;"><b>4</b>.<b>Program Structure</b></div><img src="CH9 Virtual Memory_files/D5.png" type="image/png" data-filename="D5.png" width="374.58333333333337px"/><div style="padding-left:40px;">5.<b>I/O interlock</b></div><div style="padding-left:40px;"><b>I/O interlock </b>-Pages must sometimes be locked into memory</div><div style="padding-left:40px;">-Consider I/O</div><div style="padding-left:80px;">Pages that are used for copying a file from a device must be locked from being selected as victim by a page replacement algorithm</div><div style="padding-left:40px;"><b>Pinning </b>of pages to lock into memory</div><h2>9.10 Operating-System Examples</h2><div style="padding-left:40px;"><b>1.Windows</b></div><div style="padding-left:40px;">-Uses demand paging with <b>clustering.</b> Clustering  brings in pages surrounding the faulting page</div><div style="padding-left:40px;">-Processes are assigned <b>working set minimum </b>and  <b>working set maximum</b></div><div style="padding-left:40px;">-Working set minimum is the minimum number of  pages the process is guaranteed to have in memory</div><div style="padding-left:40px;">-A process may be assigned as many pages up to  its working set maximum</div><div style="padding-left:40px;">-When the amount of free memory in the system  falls below a threshold, <b>automatic working set trimming </b>is  performed to restore the amount of free memory:     工作集修剪从进程中删除页面超过其工作集最小值的页面</div><div style="padding-left:40px;"><b>2.Solaris</b></div><div style="padding-left:40px;"><b>-</b>Maintains a list of free pages to assign  faulting processes</div><div style="padding-left:40px;">-<b>Lotsfree </b>– threshold parameter (amount of free  memory) to begin paging (out)</div><div style="padding-left:40px;">-<b>Desfree </b>– threshold parameter to increasing  paging, if it cannot keep, begin swapping processes</div><div style="padding-left:40px;">-<b>Minfree </b>– threshold parameter that page out  for every request</div><div style="padding-left:40px;">-Paging is performed by <b>pageout </b>process</div><div style="padding-left:40px;">-<b>Pageout </b>scans pages using modified clock  algorithm</div><div style="padding-left:40px;">-<b>Scanrate </b>is the rate at which pages are  scanned. This ranges from <b>slowscan </b>to <b>fastscan</b></div><div style="padding-left:40px;"><b>-Pageout </b>is called more frequently depending  upon the amount of free memory available</div><div style="padding-left:40px;">-<b>Priority paging </b>gives priority to process code  pages</div></span>
</div></body></html> 