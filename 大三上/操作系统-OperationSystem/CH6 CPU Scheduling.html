<html>
<head>
  <title>CH6 CPU Scheduling</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602326 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="870"/>
<h1>CH6 CPU Scheduling</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/12/17 21:19</i></td></tr>
<tr><td><b>作者：</b></td><td><i>dmadkr1217</i></td></tr>
</table>
</div>
<br/>

<div><span><h1>CH6 CPU Scheduling</h1><div><b>1.Basic Concepts</b></div><div style="padding-left:40px;">Maximum CPU utilization obtained with multiprogramming</div><div style="padding-left:40px;"><b>CPU–I/O Burst Cycle</b> –Process execution consists of a <b>cycle </b>of CPU execution  and I/O wait</div><div style="padding-left:40px;">CPU burst followed by I/O burst</div><div><b>2.CPU Scheduler</b></div><div style="padding-left:40px;"><b>Short-term scheduler </b>selects from among the processes<b> in ready queue,</b> and  <b>allocates the CPU</b> to <b>one </b>of them</div><div style="padding-left:40px;">CPU<b> nonpreemptive</b> sheduling take place when a process:</div><div style="padding-left:80px;">1.Switches from running to waiting state（I/O or invokewait()）</div><div style="padding-left:80px;">2.Switches from running to ready state(interrupt occurs)</div><div style="padding-left:80px;">3.Switches from waiting to ready(at completion of I/O)</div><div style="padding-left:80px;">4.Terminates</div><div style="padding-left:40px;">CPU<b> preemptive</b> scheduling</div><div style="padding-left:80px;">1.Consider access to shared data</div><div style="padding-left:80px;">2.Consider preemption while in kernel mode</div><div style="padding-left:80px;">3.Consider interrupts occurring during crucial OS activities</div><div><b>3.Dispatcher   调度器</b></div><p style="padding-left:40px;">switching context</p><p style="padding-left:80px;">switching to user mode</p><div style="padding-left:80px;">jumping to the proper location in the user program to restart that program</div><div style="padding-left:40px;"><b>Dispatch latency </b>–time it takes for the dispatcher to stop one process and  start another running</div><div>4.<span style="background-color: #ffdebd;"><b>Scheduling Criteria</b></span></div><div style="padding-left:40px;"><b>CPU utiliztion</b>    -keep CPU as busy as possible</div><div style="padding-left:40px;"><b>Throughput </b>   -#of processes that complete their execution per time unit</div><div style="padding-left:40px;"><b>Turnaround time</b>    -time to execute a particular process</div><div style="padding-left:40px;"><b>Waiting time</b>    -time a process has been waiting in the ready queue</div><div style="padding-left:40px;"><b>Response time</b>    -time from request untill the first response</div><div style="padding-left:40px;">-scheduling Algorithm optimization criteria</div><div style="padding-left:80px;">MAX <b>CPU utiliztion</b></div><div style="padding-left:80px;"><b>MAX Throughput</b></div><div style="padding-left:80px;"><b>MIN turnaround time</b></div><div style="padding-left:80px;"><b>MIN Waiting time</b></div><div style="padding-left:80px;"><b>MIN Response time</b></div><h2>    <span style="background-color: #ffdebd;"><b>cpu调度算法</b></span></h2><div style="padding-left:40px;"><b>1.FCFS(First-come,First-Served) Scheduling</b></div><img src="CH6 CPU Scheduling_files/B1.png" type="image/png" data-filename="B1.png" width="407px"/><div style="padding-left:40px;">-Convoy effect    -short progress behind long process</div><div style="padding-left:80px;">Consider one CPU-bound and many I/O -bound</div><div style="padding-left:40px;"><b>2.SJF(Sshortest-Job-First) Sheduling</b></div><img src="CH6 CPU Scheduling_files/B2.png" type="image/png" data-filename="B2.png" width="405.34792122538295px"/><div style="padding-left:40px;">-Esitimate length of next CPU Burst</div><img src="CH6 CPU Scheduling_files/B3.png" type="image/png" data-filename="B3.png" width="406px"/><div style="padding-left:40px;"><b>3.Shortest-remaining-time-first(Preemptive SJF) Scheduling</b></div><div style="padding-left:80px;">The next CPU<b> burst of the newly arrived process</b> may be shorter than what is left of the currently executing process</div><div style="padding-left:80px;">P2&lt;P4&lt;P1&lt;P3 顺序： P1-&gt;P2-&gt;P4-&gt;P1-&gt;P3</div><img src="CH6 CPU Scheduling_files/B4.png" type="image/png" data-filename="B4.png" width="474.58762886597935px"/><div style="padding-left:80px;"><b>4.Priority Scheduling</b></div><div style="padding-left:80px;">The CPU is allocated to the process with the <b>highest priority (smallest integer </b>= highest priority)</div><div style="padding-left:80px;">SFJ is PS where priority is the inverse of predicted next CPU burst time</div><div style="padding-left:80px;">-Problem:   <b> Starvation</b>: low process may never execute</div><div style="padding-left:80px;">-Solution:     <b>Aging</b>–as time progresses increase the priority of the process</div><img src="CH6 CPU Scheduling_files/B5.png" type="image/png" data-filename="B5.png" width="434px"/><div style="padding-left:80px;"><b>5.Round Robin(RR)</b></div><p style="padding-left:120px;">Each process gets a small unit of CPU time (<b>timequantum</b><i>q</i>), usually 10-100  milliseconds.  After this time has elapsed, the process is preempted and  added to the end of the ready queue.</p><div style="padding-left:120px;">If there are <i>n</i>processes in the ready queue and the time quantum is <i>q</i>, then  each process gets 1/<i>n</i>of the CPU time in chunks of at most <i>q</i>time units at  once.  No process waits more than (<i>n</i>-1)<i>q </i>time units.</div><div style="padding-left:120px;"><b>Performance</b></div><p style="padding-left:160px;">p<i>q</i>large ÞFIFO</p><div style="padding-left:160px;">p<i>q </i>small Þ<i>q </i>must be large with respect to context switch, otherwise overhead  is too high</div><img src="CH6 CPU Scheduling_files/B6.png" type="image/png" data-filename="B6.png" width="431px"/><div style="padding-left:40px;"><b>5.Multilevel Queue</b></div><div style="padding-left:80px;">Ready queue is partitioned into separate queues, eg:</div><p style="padding-left:120px;"><b>foreground</b>(interactive)  - RR</p><div style="padding-left:120px;"><b>background</b>(batch) - FCFS</div><div style="padding-left:80px;">Process permanently assigned a given queue</div><div style="padding-left:80px;">Scheduling must be done between the queues:</div><p style="padding-left:120px;"><b>Fixed priority scheduling</b>; (i.e., serve all from foreground then from  background).  Possibility of starvation.</p><p style="padding-left:120px;"><b>Time slice</b> –each queue gets a certain amount of CPU time which it can  schedule amongst its processes; i.e., 80% to foreground in RR</p><div style="padding-left:120px;">p20% to background in FCFS</div><img src="CH6 CPU Scheduling_files/B7.png" type="image/png" data-filename="B7.png" width="531.4227642276423px"/><div style="padding-left:80px;"><b>Multilevel Feedback Queue</b></div><div style="padding-left:120px;"><b>-</b>A process can move between the various queues; aging can be implemented  this way</div><div style="padding-left:120px;">-Multilevel-feedback-queue scheduler defined by the following:</div><p style="padding-left:160px;"><b>number</b> of queues</p><p style="padding-left:160px;"><b>scheduling algorithms</b> for each queue</p><p style="padding-left:160px;">method used to determine <b>when to upgrade a process</b></p><p style="padding-left:160px;">method used to determine <b>when to demote a process</b></p><div style="padding-left:160px;">method used to determine <b>which queue a process will enter when that  process needs service</b></div><img src="CH6 CPU Scheduling_files/Image.png" type="image/png" data-filename="Image.png"/><div style="padding-left:120px;"><br/></div><div style="padding-left:40px;">6.<b>Thread Scheduling</b></div><div><br/></div><div><br/></div><div style="padding-left:40px;"><b>7.Multicore Scheduling</b></div><div><br/></div><div><br/></div><div style="padding-left:40px;"><b>8.Real-Time CPU Scheduling</b></div><div style="padding-left:80px;">1.<b>Soft real-time systems </b>–no guarantee as to when critical real-time process  will be scheduled</div><div style="padding-left:120px;">只能保证critical real time process比非critical的进程优先</div><div style="padding-left:80px;">2.<b>Hard real-time systems</b>–task must be serviced by its deadline</div><div style="padding-left:80px;">Two types of latencies affect performance</div><p style="padding-left:120px;">1.Interrupt latency –time from <b>arrival of interrupt</b> to<b> start of routine</b> that services interrupt</p><div style="padding-left:120px;">2.Dispatch latency –time for <b>schedule to take current process off </b>CPU and <b>switch to another</b></div><div style="padding-left:80px;"><b>Conflict  phase</b> of diapatch latency:</div><div style="padding-left:120px;">1.Preemption of any process running in Kernel mode</div><div style="padding-left:120px;">2.Release by low-priority process of resources needed by high-proority process</div><h2>        <span style="background-color: #ffdebd;">  CPU 实时调度算法</span></h2><div style="padding-left:80px;">1.<b>Priority-based Scheduling</b></div><div style="padding-left:120px;">time scheduling, scheduler must support preemptive, priority-based  scheduling</div><div style="padding-left:120px;"> 只满足soft real time，不满足hard real time</div><div style="padding-left:160px;">Processes have new characteristics: <b>periodic </b>ones require CPU at constant  intervals</div><p style="padding-left:200px;">Has processing time <i>t</i>, deadline <i>d, </i>period <i>p</i></p><p style="padding-left:200px;">0 ≤ <i>t</i>≤ <i>d</i>≤ <i>p</i></p><div style="padding-left:200px;"><b>Rate </b>of periodic task is 1/<i>p</i></div><div style="padding-left:120px;">2.<b>Rate Monotonic Scheduling</b></div><p style="padding-left:160px;">A priority is assigned based on the inverse of its period</p><p style="padding-left:200px;">Shorter periods = higher priority;</p><p style="padding-left:200px;">Longer periods = lower priority</p><p style="padding-left:160px;">if a set of processes cannot be scheduled by this algorithm, it cannot be scheduled bany other algorithm that assigns static priorities</p><img src="CH6 CPU Scheduling_files/C3.png" type="image/png" data-filename="C3.png" width="418px"/><img src="CH6 CPU Scheduling_files/C1.png" type="image/png" data-filename="C1.png" width="421px"/><img src="CH6 CPU Scheduling_files/C2.png" type="image/png" data-filename="C2.png" width="431.3943661971831px"/><div style="padding-left:120px;">3.<b>Earliest Deadline First Scheduling (EDF)</b></div><div style="padding-left:160px;">Priorities are assigned according to deadlines:</div><div style="padding-left:200px;">the earlier the deadline, the  higher the priority;</div><div style="padding-left:200px;">the later the deadline, the lower the priority</div><img src="CH6 CPU Scheduling_files/C4.png" type="image/png" data-filename="C4.png" width="459.1079258010118px"/><div style="padding-left:120px;">4.<b>Proportional Share Scheduling</b></div><div style="padding-left:120px;"><b>Proportional share </b>schedulers operate by allocating <i>T </i>shares among all applications. An application can receive <i>N </i>shares of time, thus ensuring that the application will have <i>N</i>/<i>T </i>of the total processor time.</div><div style="padding-left:40px;"><b>9.Algorithm Evaluation</b></div><div style="padding-left:80px;"> select CPU-scheduling algorithm for an OS?</div><div style="padding-left:80px;">Determine criteria, then evaluate algorithms</div><div style="padding-left:80px;"><b>Deterministic modeling</b></div><p style="padding-left:120px;">Type of <b>analytic evaluation</b></p><div style="padding-left:120px;">Takes a particular predetermined workload and defines the performance of  each algorithm for that workload</div><div style="padding-left:80px;"><b>-Queueing Models</b></div><div style="padding-left:120px;">Describes the arrival of processes, and CPU and I/O bursts probabilistically</div><div style="padding-left:80px;">-<b>Little</b>’<b>s Formula</b></div><div style="padding-left:120px;"><br/></div><div style="padding-left:120px;">n = average queue length</div><div style="padding-left:120px;">w = average waiting time in que</div><div style="padding-left:120px;"><i>λ</i>= average arrival rate into queue</div><div style="padding-left:120px;">Little’s law     –in steady state, processes leaving queue must equal processes  arriving, thus:</div><div style="padding-left:160px;"><b><i>n </i>= <i>λ </i>x<i>W</i></b></div><div>For example, if on average 7 processes arrive per second, and normally 14  processes in queue, then average wait time per process = 2 seconds</div><div style="padding-left:120px;"><br/></div></span>
</div></body></html> 