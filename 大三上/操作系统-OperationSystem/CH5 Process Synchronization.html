<html>
<head>
  <title>CH5: Process Synchronization</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602326 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="866"/>
<h1>CH5: Process Synchronization</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/12/17 16:31</i></td></tr>
<tr><td><b>作者：</b></td><td><i>dmadkr1217</i></td></tr>
</table>
</div>
<br/>

<div><span><h1><span style="background-color: #ffdebd;">CH5: Process Synchronization</span></h1><div style="padding-left:40px;"><b>-Back ground</b></div><div style="padding-left:80px;">processes execute concurrently</div><div style="padding-left:120px;">may be interrupted at any time</div><div style="padding-left:80px;">concurrent access to shared data may result in data inconsistency</div><div style="padding-left:80px;">maintaining data inconsistency: mechanisms ensure the orderly execution of cooperating processes</div><div style="padding-left:80px;">Problem:</div><div style="padding-left:120px;"><b>consumer-producer problem</b></div><div style="padding-left:160px;">Increment refers to error when coccurently, peoblem happens because e allowed both processes to manipulate the variable counter concurrently.,<b> A race condition</b></div><div style="padding-left:160px;">Soving : process synchronization, coordination</div><img src="CH5 Process Synchronization_files/A8.png" type="image/png" data-filename="A8.png" width="488.2226277372263px"/><div style="padding-left:120px;"> 如何解决生产者消费者问题：</div><div style="padding-left:160px;">在缓冲区为空时，消费者不能再进行消费</div><div style="padding-left:160px;">在缓冲区为满时，生产者不能再进行生产</div><div style="padding-left:160px;">在一个线程进行生产或消费时，其余线程不能再进行生产或消费等操作，即保持线程间的同步</div><div style="padding-left:160px;">注意条件变量与互斥锁的顺</div><div style="padding-left:40px;">var items = 0, space = 10, mutex = 1;</div><p style="padding-left:40px;">var in = 0, out = 0;</p><p style="padding-left:40px;">item buf[10] = { NULL };</p><p style="padding-left:80px;">producer {</p><p style="padding-left:80px;">    while( true ) {</p><p style="padding-left:80px;">        wait( space );  // 等待缓冲区有空闲位置， 在使用PV操作时，条件变量需要在互斥锁之前</p><p style="padding-left:80px;">        wait( mutex );  // 保证在product时不会有其他线程访问缓冲区</p><p style="padding-left:80px;">        // product</p><p style="padding-left:80px;">        buf.push( item, in );  // 将新资源放到buf[in]位置 </p><p style="padding-left:80px;">        in = ( in + 1 ) % 10;</p><p style="padding-left:80px;"><br/></p><p style="padding-left:80px;">        signal( mutex );  // 唤醒的顺序可以不同</p><p style="padding-left:80px;">        signal( items );  // 通知consumer缓冲区有资源可以取走</p><p style="padding-left:80px;">    }</p><p style="padding-left:80px;">}</p><p style="padding-left:80px;">consumer {</p><p style="padding-left:80px;">    while( true ) {</p><p style="padding-left:80px;">        wait( items );  // 等待缓冲区有资源可以使用</p><p style="padding-left:80px;">        wait( mutex );  // 保证在consume时不会有其他线程访问缓冲区</p><p style="padding-left:80px;">        // consume</p><p style="padding-left:80px;">        buf.pop( out );  // 将buf[out]位置的的资源取走</p><p style="padding-left:80px;">        out = ( out + 1 ) % 10;</p><p style="padding-left:80px;">        signal( mutex );  // 唤醒的顺序可以不同</p><p style="padding-left:80px;">        signal( space );  // 通知缓冲区有空闲位置</p><p style="padding-left:80px;">    }</p><p style="padding-left:80px;">}</p><p style="padding-left:40px;"><b>2</b><span style="background-color: #ffdebd;"><b>.Critical Section Problem</b></span></p><p style="padding-left:80px;">consider a system of n processses{p0, p1,..,pn-1)</p><p style="padding-left:80px;">each process has a segment of code, called <b>critical section</b></p><p style="padding-left:120px;">-process may be changing common cariables, updating able, writing file, etc</p><p style="padding-left:120px;">-when one progress in critical section, no other may be in its critical section</p><div style="padding-left:80px;"><b>Critical section problem </b></div><div style="padding-left:120px;">To design  protocol that the process can use to cooperate</div><div style="padding-left:120px;">Each process must ask permission (<b>entry section</b>) to enter critical section, may be followed by <b>exit section</b>, then <b>remainder section</b></div><div style="padding-left:80px;">General structure of process Pi</div><div style="padding-left:120px;">do(</div><div style="padding-left:160px;">entry section(while (trun == j);)</div><div style="padding-left:200px;"><b>critical section</b></div><div style="padding-left:160px;">exit section   (turn = j;)</div><div style="padding-left:200px;"><b>remainder section</b></div><div style="padding-left:160px;">}while(true);</div><div style="padding-left:40px;"><b>3.Solution to Critical-Section Problem</b></div><div style="padding-left:80px;"><b>1.Mutual Exclusion</b>    -If process Pi is executing in its critical section, no other process can be executing in thier critical sections</div><div style="padding-left:80px;"><b>2.Progress</b>    -下一个要进入critical section的progress不能无限期延迟</div><div style="padding-left:80px;"><b>3.Bounded Waiting</b>    -A bound must exist on the number of times that other processes are allowed to enter their critical sections after a progress has made a request to enter its critical section and before the request is granted 规定等待的最长时间</div><div style="padding-left:40px;"><span style="background-color: #ffdebd;"><b>4.Critical Section Handing in OS</b></span></div><div style="padding-left:80px;">Two approaches depending on if kernel is <b>preemptive</b> or<b> non-preemptive </b></div><div style="padding-left:80px;"><b>1.preemptive（抢占式）</b></div><div style="padding-left:120px;">allows a process to be preempted while it is running in kernel mode. </div><div style="padding-left:80px;"><b>2.Non-preemptive (非抢占式）</b></div><div style="padding-left:120px;">runs until it exits kernel mode, blocks or voluntarily yields CPU</div><div style="padding-left:80px;">A preemptive kernel may be more responsive, since there is less risk that a kernel-mode process will run for an arbitrarily long period</div><div style="padding-left:40px;"><b>5.Peterson's Solution</b></div><p style="padding-left:80px;">The variable <b>turn </b>indicates whose turn it is to enter the critical section</p><div style="padding-left:80px;">The <b>flag </b>array indicates if a process is ready to enter the critical section.  <b>flag[i] = <i>true </i></b>implies that process <b>Pi </b>is ready!</div><div style="padding-left:80px;">-Algorothm for Process Pi(Pj)</div><div style="padding-left:120px;"><b>Pi:</b></div><div style="padding-left:120px;">do{</div><div style="padding-left:160px;"><b>flag[i] = true;</b></div><div style="padding-left:160px;"><b>turn = j;</b></div><div style="padding-left:160px;"><b>while(flag[j] &amp;&amp; turn == j) ;</b></div><div style="padding-left:200px;">critical section</div><div style="padding-left:160px;"><b>flag[i] = false;</b></div><div style="padding-left:200px;">remainder section</div><div style="padding-left:120px;">}while(true);</div><div style="padding-left:120px;"><b>Pj:</b></div><div style="padding-left:120px;">do{</div><div style="padding-left:160px;"><b>flag[j] = true;</b></div><div style="padding-left:160px;"><b>turn = i;</b></div><div style="padding-left:160px;"><b>while(flag[i] &amp;&amp; turn == i) ;</b></div><div style="padding-left:200px;">critical section</div><div style="padding-left:160px;"><b>flag[j] = false;</b></div><div style="padding-left:200px;">remainder section</div><div style="padding-left:160px;">}while(true);</div><div style="padding-left:120px;">Three requiements:</div><div style="padding-left:160px;">1.Mutual exclusion is preseved</div><div style="padding-left:160px;">Pi enters CS only if:</div><div style="padding-left:200px;">either flag[j] = false or turn = i;</div><div style="padding-left:160px;">2.Progress requirements is satisfied</div><div style="padding-left:160px;">3.Bounded-waiting requirement is met</div><div style="padding-left:80px;"><span style="background-color: #ffdebd;"><b>6.Synchronization Hardware</b></span></div><div style="padding-left:120px;">-Locking</div><div style="padding-left:120px;">-Uniprocessor: disable interrupts, execute without preemption</div><div style="padding-left:120px;">-Atomic hardware instructions: </div><div style="padding-left:120px;"><b>-Using locks</b></div><div style="padding-left:120px;">do{</div><div style="padding-left:160px;">//acquire lock</div><div style="padding-left:200px;">critical section</div><div style="padding-left:160px;">//release lock</div><div style="padding-left:200px;">remainder section</div><div style="padding-left:120px;">}while(true);</div><div style="padding-left:120px;">-special hardware instructions that allow us either to <b>test and modify</b> the content of a word or to <b>swap the contents </b>of two words <b>atomically</b></div><div style="padding-left:160px;"><b>1.test_and_set</b></div><div style="padding-left:200px;">boolean test_and_set (boolean *target)</div><div style="padding-left:200px;">{</div><div style="padding-left:240px;">boolean rv = *target;</div><div style="padding-left:240px;">*target = TRUE;</div><div style="padding-left:240px;">return rv;</div><div style="padding-left:200px;">}</div><p style="padding-left:200px;">1.Executed atomically</p><p style="padding-left:200px;">2.Returns the original value of passed parameter</p><div style="padding-left:200px;">3.Set the new value of passed parameter to “TRUE”.</div><div style="padding-left:160px;"><b>solution: shared boolean variable lock, initialized to FALZE</b></div><div style="padding-left:200px;">do{</div><div style="padding-left:280px;">while(test_and_set(&amp;lock))</div><div style="padding-left:320px;">;</div><div style="padding-left:320px;">/*critical section*/</div><div style="padding-left:240px;">lock = false;</div><div style="padding-left:320px;">/*remainder section*/</div><div style="padding-left:200px;">}while(true);</div><div style="padding-left:160px;"><b>2.compare_and_swap</b></div><div style="padding-left:200px;">int compare_and_swap(int *value, int *expected, int new_value) {</div><div style="padding-left:240px;">int temp = *value;</div><div style="padding-left:240px;">if(*value == expected)</div><div style="padding-left:280px;">*value = new_value;</div><div style="padding-left:240px;">return temp;</div><p style="padding-left:200px;">1.Executed atomically</p><p style="padding-left:200px;">2.Returns the original value of passed parameter “value”</p><div style="padding-left:200px;">3.Set  the variable “value”as the passed parameter “new_value”only if  “value”==“expected</div><div style="padding-left:160px;"><b>solution:shared integer &quot;lock&quot; initialized to 0   </b> </div><div style="padding-left:200px;">do{</div><div style="padding-left:240px;">while (compare_and_swap(&amp;lock, 0, 1) != 0)</div><div style="padding-left:280px;">;</div><div style="padding-left:280px;">/*critical sextion*/</div><div style="padding-left:240px;">lock = 0;</div><div style="padding-left:280px;">/*remiander section*/</div><div style="padding-left:240px;">}while true.</div><div style="padding-left:160px;"><b>3.Bounded-waiting Mutual Exclusion with test_and_set</b></div><div style="padding-left:200px;">boolean waiting[n];</div><div style="padding-left:200px;">boolean lock;</div><div style="padding-left:200px;">do{</div><div style="padding-left:240px;">waiting[i] = true;</div><div style="padding-left:240px;">key = true;</div><div style="padding-left:240px;">while(waiting[i] &amp;&amp; key)</div><div style="padding-left:280px;">key = test_and_set(&amp;lock);</div><div style="padding-left:240px;">waiting[i] = false;</div><div style="padding-left:280px;">/*critical section*/</div><div style="padding-left:240px;">j = (i + 1） % n</div><div style="padding-left:240px;">while((j != 1) &amp;&amp; !waiting[j])</div><div style="padding-left:280px;">j = (i + 1） % n</div><div style="padding-left:240px;">if（j == i)</div><div style="padding-left:280px;">lock = false;</div><div style="padding-left:240px;">else</div><div style="padding-left:280px;">waiting[j] = false</div><div style="padding-left:280px;">/*remainder section*/</div><div style="padding-left:200px;">}while(true);</div><div style="padding-left:160px;"><b>4.swap</b></div><div style="padding-left:200px;">void swap(boolean *a, boolean *b)</div><div style="padding-left:200px;">{</div><div style="padding-left:240px;">boolean temp = *a;</div><div style="padding-left:240px;">*a = *b;</div><div style="padding-left:240px;">*b = temp;</div><div style="padding-left:200px;">}</div><div style="padding-left:200px;"><br/></div><div style="padding-left:200px;">lock = false;</div><div style="padding-left:200px;">do{</div><div style="padding-left:240px;">key = true;</div><div style="padding-left:240px;">do{</div><div style="padding-left:280px;">swap(&amp;lock, &amp;key)；</div><div style="padding-left:240px;">}while(key);</div><div style="padding-left:240px;">//critical section</div><div style="padding-left:240px;">lock = false;</div><div style="padding-left:200px;">}while(true);</div><div style="padding-left:200px;">//initial lock as false</div><div style="padding-left:80px;"><span style="background-color: #ffdebd;"><b>7.Mutex Locks</b></span></div><div style="padding-left:120px;">acquire() to lock</div><div style="padding-left:120px;">release() the lock</div><div style="padding-left:120px;">calls tp acquire() and release() must be atomic</div><div style="padding-left:120px;">requires<span style="background-color: #ffdebd;"> <b>busy waiting</b></span>, the lock called a <b>spinlock//自旋锁, </b>as the process spins while waiting for lock becoming available</div><div style="padding-left:120px;"><b>Busy waiting: </b>While a process is in its critical section, any other process that tries to enter its critical section must <b>loop continuously in the call to acquire().</b></div><div style="padding-left:120px;"><b>-acquire() {</b></div><div style="padding-left:160px;"><b>while(!available)</b></div><div style="padding-left:200px;"><b>; /*busy wait*/</b></div><div style="padding-left:160px;"><b>available = false;</b></div><div style="padding-left:120px;"><b>}</b></div><div style="padding-left:120px;"><b>-release() {</b></div><div style="padding-left:160px;"><b>available = true;</b></div><div style="padding-left:120px;"><b>}</b></div><div style="padding-left:120px;">do {</div><div style="padding-left:160px;">acquire lock</div><div style="padding-left:200px;">critical section</div><div style="padding-left:160px;">releaselock</div><div style="padding-left:200px;">remainder section</div><div style="padding-left:120px;">}while(true);</div><div style="padding-left:80px;"><span style="background-color: #ffdebd;"><b>8.Semaphore 信号量</b></span><b>（PV操作）</b></div><div style="padding-left:120px;">Synchronization tool that provides<b> more sophisticated ways (than Mutex locks)</b>  for  process to synchronize their activities.</div><div style="padding-left:120px;">Semaphore S =&gt; integer variable</div><div style="padding-left:160px;">-wait() and signal()</div><div style="padding-left:200px;">called P() and V()</div><div style="padding-left:160px;"><b>-wait()</b></div><div style="padding-left:200px;">wait(S){</div><div style="padding-left:240px;">while(S &lt;= 0)</div><div style="padding-left:280px;">;</div><div style="padding-left:240px;">S--;</div><div style="padding-left:200px;">}</div><div style="padding-left:160px;"><b>-signal()    </b></div><div style="padding-left:200px;">signal(S)    {</div><div style="padding-left:240px;">S++;</div><div style="padding-left:200px;">}</div><div style="padding-left:160px;">when one process modifies the semaphore value, no other process can simultaneously modify that same semaphore value</div><div style="padding-left:120px;"><b>Semaphore Usage</b></div><div style="padding-left:160px;"><b>1.Counting semaphore </b>   -integer value can range over an unrestricted domain</div><div style="padding-left:160px;"><b>2.Binary semaphore</b>    -integer value can range only between 0 and 1</div><div style="padding-left:200px;">-same as <b>mutex lock</b></div><div style="padding-left:160px;">Example:require S1 to happen before S2;</div><div style="padding-left:160px;"><b>create a semaohore &quot;synch&quot; initialized to 0</b></div><div style="padding-left:160px;">P1:</div><div style="padding-left:200px;">S1;</div><div style="padding-left:200px;">signal(synch);</div><div style="padding-left:160px;">P2:</div><div style="padding-left:200px;">wait(synch);</div><div style="padding-left:200px;">S2;</div><div style="padding-left:120px;"><b>Semaphore Implementation</b></div><div style="padding-left:160px;">-Must guarantee no two processes can execute wait() and signal() on the same semaphore at the same time</div><div style="padding-left:160px;">-have<b> busy waiting</b> in critical section implementation</div><div style="padding-left:160px;">-Applications may spend lots of time in critical sections, this is not a good solution</div><div style="padding-left:160px;">Implementation with no Busy Waiting:</div><div style="padding-left:200px;">With each semaphore there is an asociated <b>waiting queue</b></div><div style="padding-left:200px;">Each entry in a <b>waiting</b> <b>queue</b> has two data items:</div><div style="padding-left:240px;">value(of type integer)</div><div style="padding-left:240px;">pointer to next record in the list</div><div style="padding-left:200px;">Two operations:</div><div style="padding-left:240px;"><b>block</b>    -place the process invoking the operation on the appropriate <b>waiting queue</b></div><div style="padding-left:240px;"><b>wakeup</b>    -remove one of processes in the waiting queue and place it in the r<b>eady queue</b></div><div style="padding-left:160px;">-代码实现：</div><div style="padding-left:200px;"><b>typedef struct{</b></div><div style="padding-left:240px;"><b>int value;</b></div><div style="padding-left:240px;"><b>sreuct process *list;</b></div><div style="padding-left:200px;"><b>} semaphore;</b></div><div><br/></div><div style="padding-left:200px;"><b>wait(semaphore *S) {</b></div><div style="padding-left:240px;"><b>S-&gt;value--;</b></div><div style="padding-left:240px;"><b>if (S-&gt;value &lt; 0) {</b></div><div style="padding-left:280px;"><b>add this process to S-&gt;list;</b></div><div style="padding-left:280px;"><b>block();</b></div><div style="padding-left:240px;"><b>}</b></div><div style="padding-left:200px;"><b>}</b></div><div><br/></div><div style="padding-left:200px;"><b>signal(semaphore *S) {</b></div><div style="padding-left:240px;"><b>S-&gt;value++;</b></div><div style="padding-left:240px;"><b>if(S-&gt;value&lt;=0) {</b></div><div style="padding-left:280px;"><b>remove a process P from S-&gt;list;</b></div><div style="padding-left:280px;"><b>wakeup(P);</b></div><div style="padding-left:240px;"><b>}</b></div><div style="padding-left:200px;"><b>}</b></div><div><br/></div><div style="padding-left:200px;">The block() operation suspends the process that invokes it. The wakeup(P) operation resumes the execution of a blocked process P. These two operations are provided by the operating system as basic system calls.</div><div style="padding-left:200px;">If a semaphore value is <b>negative, its magnitude is the number of processes waiting on that semaphore</b></div><hr/><div><br/></div><div style="padding-left:200px;">The list of waiting processes can be easily implemented by a link field in each process control block (PCB). Each semaphore contains an integer value and a pointer to a list of PCBs.</div><div style="padding-left:200px;">moved busy waiting from the entry section to the critical sections of application programs of the wait() and signal() operations, there sections are short, busy waiting occurs rarely</div><div style="padding-left:80px;"><span style="background-color: #ffdebd;"><b>9.Deadlock and Starvation 死锁和饥饿</b></span></div><div style="padding-left:120px;"><b>Deadlock </b>   -two or more processes are waiting indefinitely for an event that can be caused by only one of the waiting processes</div><div style="padding-left:120px;">P0            P1</div><div style="padding-left:120px;">wait(s)    wait(Q)</div><div style="padding-left:120px;">wait(Q)    wait(S)</div><div style="padding-left:120px;">...            ...</div><div style="padding-left:120px;">signal(s)    signal(Q)</div><div style="padding-left:120px;">signall(Q)    signal(S)</div><div style="padding-left:120px;"><b>Starvation    -indefinite blocking</b></div><div style="padding-left:160px;">-A process nay never be removed from the semaphore queue in which it is suspended</div><div style="padding-left:120px;"><b>Priority inversion </b>   优先级翻转</div><div style="padding-left:160px;">-Scheduling problem when lower-priority process holds a lock needed by higher-priority process</div><div style="padding-left:200px;">solved via <b>priority-inheritance protocol(threeprocesses,L&lt;M&lt;H)</b></div><div style="padding-left:200px;">M请求L，L继承H优先级，并先于M执行，执行后恢复优先级到L</div><div style="padding-left:80px;"><span style="background-color: #ffdebd;"><b>10.Classical Problems of Synchronization 进程同步的三个经典问题</b></span></div><div style="padding-left:120px;"><b>1</b><span style="background-color: #ffdebd;">.<b>Bounded-Buffer Problem(使用信号量PV操作解决）</b></span></div><div style="padding-left:160px;"><b>int n;</b></div><div style="padding-left:160px;"><b>semaphore mutex = 1;</b></div><div style="padding-left:160px;"><b>semaphore empty = n;</b></div><div style="padding-left:160px;"><b>semaphore full = 0;</b></div><div style="padding-left:160px;"><b>-Producer：</b></div><div style="padding-left:160px;">do{</div><div style="padding-left:200px;">//prodcu an item in next_produced</div><div style="padding-left:200px;">wait(empty);</div><div style="padding-left:200px;">wait(mutex);</div><div style="padding-left:200px;">//add next)produced to the buffer;</div><div style="padding-left:200px;">signal(mutex)</div><div style="padding-left:200px;">signal(full)</div><div style="padding-left:160px;">}while(true);</div><div style="padding-left:160px;"><b>reciever：</b></div><div style="padding-left:160px;">do {</div><div style="padding-left:200px;"><b>wait(full);</b></div><div style="padding-left:200px;"><b>wait(mutex);</b></div><div style="padding-left:200px;">...</div><div style="padding-left:200px;">/*remove an item from buffer to next_consumed*/</div><div style="padding-left:200px;">...</div><div style="padding-left:200px;"><b>signal(mutex);</b></div><div style="padding-left:200px;"><b>signal(empty);</b></div><div style="padding-left:200px;">...</div><div style="padding-left:200px;">/*consume the item in next_consumed*/</div><div style="padding-left:200px;">...</div><div style="padding-left:160px;">}while(true);</div><div style="padding-left:120px;"><span style="background-color: #ffdebd;"><b>2.Readers-Writers Problem</b></span></div><div style="padding-left:160px;">A data set is shared among concurrent processes</div><div style="padding-left:200px;">readers - only read, do not update</div><div style="padding-left:200px;">Writers -  both read and write</div><div style="padding-left:160px;"><b>Problem:    </b>-allow multiple users read at the same time</div><div style="padding-left:200px;">&gt;only one writer can access the shared data at the same time</div><div style="padding-left:160px;"><b>semaphore rw_mutex = 1;</b></div><div style="padding-left:160px;"><b>semaphore mutex = 1;</b></div><div style="padding-left:160px;"><b>int read_count = 0;</b></div><div style="padding-left:160px;">//if a writer is in the critical section and <i>n </i>readers are waiting, then one reader is queued on rw mutex, and <i>n </i>− 1 readers are queued on mutex</div><div style="padding-left:160px;">Structure of <b>Writer</b> Process:</div><div style="padding-left:200px;">do{</div><div style="padding-left:240px;">wait(rw_mutex);</div><div style="padding-left:240px;">...</div><div style="padding-left:240px;">/*writing is performed*/</div><div style="padding-left:240px;">...</div><div style="padding-left:240px;">signal(rw_mutex);</div><div style="padding-left:200px;">}while(true);</div><div style="padding-left:160px;">Structure of <b>Reader</b> Process:</div><div style="padding-left:200px;">do{</div><div style="padding-left:240px;"><b>wait(mutex);</b></div><div style="padding-left:240px;">read_count++;</div><div style="padding-left:240px;">if(read_count == 1)</div><div style="padding-left:280px;"><b>wait(rw_mutex);</b></div><div style="padding-left:240px;"><b>signal(mutex);</b></div><div style="padding-left:240px;">...</div><div style="padding-left:240px;">/*reading is performed*/</div><div style="padding-left:240px;">...</div><div style="padding-left:240px;"><b>wait(mutex);</b></div><div style="padding-left:240px;">read_count--;</div><div style="padding-left:240px;">if(read_count == 0)</div><div style="padding-left:280px;"><b>signal(rw_mutex);</b></div><div style="padding-left:240px;"><b>signal(mutex);</b></div><div style="padding-left:200px;">}while(true);</div><div style="padding-left:160px;"><b>-Problem Variations</b></div><div style="padding-left:200px;"><b>First</b>    -no reder be kept waiting unless a writer has permission to use shared objext</div><div style="padding-left:240px;">(reader-preference writer starcation)</div><div style="padding-left:200px;"><b>Second</b>    -once a writer is ready, it performes write ASAP</div><div style="padding-left:240px;">(write[preference, reader starvation)</div><div style="padding-left:120px;"><span style="background-color: #ffdebd;">3.<b>Dining-Philosophers Problem</b></span></div><p style="padding-left:160px;">Philosophers spend their lives alternating thinking and eating</p><div style="padding-left:160px;">Don’t interact with their neighbors, occasionally try to pick up<b> 2 chopsticks</b> (one at a  time) to eat from bowl</div><div style="padding-left:160px;"><b>Need both chopsticks to eat, then release both when done</b></div><div><br/></div><div style="padding-left:160px;">semaphore chopstick[5];</div><div><br/></div><div style="padding-left:160px;">do{</div><div style="padding-left:200px;">wait(chopstick[i]);</div><div style="padding-left:200px;">wait(chopstick[(i+1)%5]);</div><div style="padding-left:200px;">...</div><div style="padding-left:200px;">//eat</div><div style="padding-left:200px;">...</div><div style="padding-left:200px;">signal(chopstick[i]);</div><div style="padding-left:200px;">signal(chopstick[(i+1)%5]);</div><div style="padding-left:200px;">...</div><div style="padding-left:200px;">//think</div><div style="padding-left:160px;">}while(true);</div><div style="padding-left:160px;">p<b>roblem:</b></div><div style="padding-left:200px;">may create dead lock, if all philosophers become hungry at the same time and each grabs her left chopstick, all chopstick[i] becomes 0, deadlock</div><div style="padding-left:160px;"><b>Deadlock handling:</b></div><div style="padding-left:200px;">1.allow at most 4 phlisophers siiting simutaneously at the table</div><div style="padding-left:200px;">2.allow a philosopher to pick up forks only if both a available</div><div style="padding-left:200px;">3.use asymmetric solution`</div><div style="padding-left:240px;">奇数的哲学家先拿左边的筷子，再拿右边的筷子；</div><div style="padding-left:240px;">偶数哲学家先拿右再拿左</div><div style="padding-left:80px;">11.<b>Problems with Semaphores</b></div><div style="padding-left:120px;">incorrect use of semphore operations:</div><div style="padding-left:120px;">先wait 后 signal ，wait与signal成对出现</div><div style="padding-left:120px;">deadlock and starvation possible</div><div style="padding-left:80px;">12.<b>Monitors</b></div><div style="padding-left:120px;">A high-level abstraction that provides a convenientand effectivemechanism for process  synchronization</div><div style="padding-left:120px;">Only one process may be active within the monitor at a time</div><div style="padding-left:120px;"><b>-condition variables</b></div><p style="padding-left:160px;"><b>conditionx, y;</b></p><div style="padding-left:200px;">Two operations are allowed on a condition variable:</div><p style="padding-left:240px;"><b>x.wait() </b>–a process that invokes the operation is suspended until  <b>x.signal() </b></p><div style="padding-left:240px;"><b>x.signal() </b>–resumes one of processes(if any)thatinvoked<b>x.wait()</b></div><div style="padding-left:280px;">If no <b>x.wait()</b>on the variable, then it has no effect on the variable</div><div style="padding-left:120px;">-<b>Condition Variables Choices</b></div><div style="padding-left:160px;">Both Q and P cannot execute in parallel. If Q is resumed, then P must wait</div><div style="padding-left:160px;"><b>Options include</b></div><p style="padding-left:160px;">1.<b>Signal and wait </b>–P waits until Q either leaves the monitor or it waits for  another condition</p><p style="padding-left:160px;">2.<b>Signal and continue </b>–Q waits until P either leaves the monitor or it  waits  for another condition</p><p style="padding-left:200px;">Both have pros and cons –language implementer can decide</p><div style="padding-left:200px;"><br/></div><div style="padding-left:80px;"><br/></div><div style="padding-left:120px;"><br/></div></span>
</div></body></html> 